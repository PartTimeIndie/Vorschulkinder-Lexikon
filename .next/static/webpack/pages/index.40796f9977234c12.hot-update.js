"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./components/Character.js":
/*!*********************************!*\
  !*** ./components/Character.js ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/image */ \"./node_modules/next/image.js\");\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_image__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _utils_assetCache__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/assetCache */ \"./utils/assetCache.js\");\n\nvar _s = $RefreshSig$();\n\n\n\n// Statische Variable um sicherzustellen dass Character nur EINMAL initialisiert wird\nlet characterInitialized = false;\n// Entferne die Hilfsfunktion getCharacterImageUrl\nconst Character = (param)=>{\n    let { currentContext = \"idle\", onEmotionChange } = param;\n    _s();\n    const [currentEmotion, setCurrentEmotion] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"idle\");\n    const [isRotating, setIsRotating] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [rotationPhase, setRotationPhase] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"idle\"); // 'idle', 'out', 'in'\n    const [availableEmotions, setAvailableEmotions] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([\n        \"idle\",\n        \"curious\"\n    ]);\n    const [hasLoaded, setHasLoaded] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(characterInitialized); // Für initiale Fly-In Animation - einmal für immer\n    const [lastProcessedContext, setLastProcessedContext] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null); // Verhindert mehrfache Emotion-Wechsel\n    const [lastEmotionChangeTime, setLastEmotionChangeTime] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0); // Cooldown für Emotion-Changes\n    const autoResetTimer = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const emotionChangeTimer = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Character-Bilder-Varianten definieren\n    const characterVariants = {\n        idle: [\n            \"/Characters/Character-idle.png\",\n            \"/Characters/Character-idle-2.png\",\n            \"/Characters/Character-idle-3.png\"\n        ],\n        excited: [\n            \"/Characters/Character-excited.png\",\n            \"/Characters/Character-excited-2.png\",\n            \"/Characters/Character-excited-3.png\"\n        ],\n        curious: [\n            \"/Characters/Character-curious.png\",\n            \"/Characters/Character-curious-2.png\",\n            \"/Characters/Character-curious-3.png\"\n        ],\n        surprised: [\n            \"/Characters/Character-surprised.png\",\n            \"/Characters/Character-surprised-2.png\",\n            \"/Characters/Character-surprised-3.png\"\n        ],\n        thinking: [\n            \"/Characters/Character-thinking.png\",\n            \"/Characters/Character-thinking-2.png\",\n            \"/Characters/Character-thinking-3.png\"\n        ],\n        laughing: [\n            \"/Characters/Character-laughing.png\",\n            \"/Characters/Character-laughing-2.png\"\n        ],\n        exploring: [\n            \"/Characters/Character-excited.png\",\n            \"/Characters/Character-excited-2.png\",\n            \"/Characters/Character-excited-3.png\"\n        ],\n        scared: [\n            \"/Characters/Character-surprised.png\",\n            \"/Characters/Character-surprised-2.png\",\n            \"/Characters/Character-surprised-3.png\"\n        ]\n    };\n    // State für gewählte Variante pro Emotion\n    const [selectedVariant, setSelectedVariant] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"/Characters/Character-idle.png\");\n    const [imgLoaded, setImgLoaded] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [imgSrc, setImgSrc] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"/Characters/Character-idle.png\");\n    // Whenever selectedVariant changes, try to load from cache\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        let objectUrl;\n        let isMounted = true;\n        if (!selectedVariant) return;\n        (0,_utils_assetCache__WEBPACK_IMPORTED_MODULE_3__.getCachedAssetAsBlob)(selectedVariant).then((blob)=>{\n            if (blob && isMounted) {\n                objectUrl = URL.createObjectURL(blob);\n                setImgSrc(objectUrl);\n            } else if (isMounted) {\n                setImgSrc(selectedVariant);\n            }\n        }).catch(()=>{\n            if (isMounted) setImgSrc(selectedVariant);\n        });\n        return ()=>{\n            isMounted = false;\n            if (objectUrl) URL.revokeObjectURL(objectUrl);\n        };\n    }, [\n        selectedVariant\n    ]);\n    // Zufällige Variante für Emotion wählen und speichern (NIEMALS die gleiche)\n    const selectVariantForEmotion = (emotion)=>{\n        const variants = characterVariants[emotion] || characterVariants.idle;\n        // Wenn nur eine Variante vorhanden, diese nehmen\n        if (variants.length === 1) {\n            const variant = variants[0];\n            setSelectedVariant(variant);\n            return variant;\n        }\n        // Aktuelle Variante rausfiltern um Wiederholung zu vermeiden\n        const otherVariants = variants.filter((variant)=>variant !== selectedVariant);\n        // Falls alle Varianten die gleiche sind (sollte nicht passieren), erste nehmen\n        if (otherVariants.length === 0) {\n            const variant = variants[0];\n            setSelectedVariant(variant);\n            return variant;\n        }\n        // Zufällige andere Variante wählen\n        const randomVariant = otherVariants[Math.floor(Math.random() * otherVariants.length)];\n        setSelectedVariant(randomVariant);\n        return randomVariant;\n    };\n    // Zufällige Emotion aus verfügbaren Emotionen wählen\n    const getRandomEmotion = function() {\n        let emotions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : availableEmotions;\n        const filtered = emotions.filter((e)=>e !== currentEmotion);\n        if (filtered.length === 0) return emotions[0];\n        return filtered[Math.floor(Math.random() * filtered.length)];\n    };\n    // Emotion-Wechsel mit ursprünglicher Flip-Animation\n    const changeEmotion = function(newEmotion) {\n        let immediate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        console.log(\"\\uD83C\\uDFAD Emotion change: \".concat(currentEmotion, \" → \").concat(newEmotion, \" (immediate: \").concat(immediate, \")\"));\n        if (newEmotion === currentEmotion) {\n            console.log(\"\\uD83C\\uDFAD Same emotion, skipping\");\n            return;\n        }\n        if (immediate) {\n            // Direkter Wechsel ohne Animation\n            console.log(\"\\uD83C\\uDFAD Immediate change to \".concat(newEmotion));\n            setCurrentEmotion(newEmotion);\n            selectVariantForEmotion(newEmotion);\n            return;\n        }\n        // Flip-Animation: Raus -> Bild wechseln -> Rein\n        console.log(\"\\uD83C\\uDFAD Starting flip animation: out → change → in\");\n        setIsRotating(true);\n        setRotationPhase(\"out\");\n        // Nach Raus-Animation (200ms): Bild wechseln\n        setTimeout(()=>{\n            console.log(\"\\uD83C\\uDFAD Flip animation: Changing image to \".concat(newEmotion));\n            setCurrentEmotion(newEmotion);\n            selectVariantForEmotion(newEmotion);\n            setRotationPhase(\"in\");\n            // Nach Rein-Animation (200ms): Animation beenden\n            setTimeout(()=>{\n                console.log(\"\\uD83C\\uDFAD Flip animation: Complete!\");\n                setRotationPhase(\"idle\");\n                setIsRotating(false);\n            }, 200);\n        }, 200);\n    };\n    // Auto-Reset entfernt - Character wechselt nur bei Interaktionen\n    // Context-abhängige Emotionen laden\n    const loadContextEmotions = async (context)=>{\n        console.log(\"\\uD83C\\uDFAD loadContextEmotions called with context: '\".concat(context, \"' (lastProcessed: '\").concat(lastProcessedContext, \"')\"));\n        try {\n            // Statt API: Definiere die Emotions-Logik clientseitig oder lade aus statischer Datei\n            // Beispiel: Mapping von Context zu Emotions\n            const contextEmotionMap = {\n                idle: [\n                    \"idle\",\n                    \"curious\"\n                ],\n                main: [\n                    \"excited\",\n                    \"curious\",\n                    \"idle\"\n                ],\n                category: [\n                    \"curious\",\n                    \"thinking\",\n                    \"excited\"\n                ],\n                animals: [\n                    \"excited\",\n                    \"surprised\",\n                    \"laughing\"\n                ],\n                default: [\n                    \"idle\",\n                    \"curious\",\n                    \"excited\",\n                    \"surprised\",\n                    \"thinking\",\n                    \"laughing\"\n                ]\n            };\n            const emotions = contextEmotionMap[context] || contextEmotionMap.default;\n            setAvailableEmotions(emotions);\n            // Der Rest bleibt gleich wie vorher\n            const now = Date.now();\n            const timeSinceLastChange = now - lastEmotionChangeTime;\n            const EMOTION_COOLDOWN = 2000; // 2 Sekunden Cooldown\n            console.log(\"\\uD83C\\uDFAD Context check: context=\".concat(context, \", lastProcessed=\").concat(lastProcessedContext, \", cooldown=\").concat(timeSinceLastChange, \"ms\"));\n            if (context !== \"idle\" && context !== lastProcessedContext && timeSinceLastChange >= EMOTION_COOLDOWN) {\n                console.log(\"\\uD83C\\uDFAD TRIGGERING emotion change for context '\".concat(context, \"'\"));\n                const randomEmotion = emotions[Math.floor(Math.random() * emotions.length)];\n                changeEmotion(randomEmotion, false); // Mit Flip-Animation\n                setLastProcessedContext(context); // Merke dass wir diesen Context schon verarbeitet haben\n                setLastEmotionChangeTime(now); // Setze Cooldown-Timer\n            } else if (context === lastProcessedContext) {\n                console.log(\"\\uD83C\\uDFAD BLOCKED: Context '\".concat(context, \"' already processed\"));\n            } else if (timeSinceLastChange < EMOTION_COOLDOWN) {\n                console.log(\"\\uD83C\\uDFAD BLOCKED: Cooldown active (\".concat(timeSinceLastChange, \"ms < \").concat(EMOTION_COOLDOWN, \"ms)\"));\n            } else if (context === \"idle\") {\n                // Bei idle-Context: Reset lastProcessedContext für nächste Interaktion (aber kein Cooldown Reset)\n                console.log(\"\\uD83C\\uDFAD RESET: Idle context, clearing lastProcessedContext\");\n                setLastProcessedContext(null);\n            // Character wird NICHT neu instanziert, nur hasLoaded bleibt true\n            }\n        } catch (error) {\n            console.error(\"Error loading context emotions:\", error);\n            setAvailableEmotions([\n                \"idle\",\n                \"curious\"\n            ]);\n        }\n    };\n    // Zufälliges Lachen abspielen (ohne Voice-Overs zu unterbrechen)\n    const playRandomLaughter = ()=>{\n        const laughterFiles = [\n            \"/audio/LaughingKid/laughing-1.wav\",\n            \"/audio/LaughingKid/laughing-2.wav\",\n            \"/audio/LaughingKid/laughing-3.wav\",\n            \"/audio/LaughingKid/laughing-4.wav\",\n            \"/audio/LaughingKid/laughing-5.wav\",\n            \"/audio/LaughingKid/laughing-6.wav\",\n            \"/audio/LaughingKid/laughing-7.wav\"\n        ];\n        // Zufällige Lacher-Datei auswählen\n        const randomLaughter = laughterFiles[Math.floor(Math.random() * laughterFiles.length)];\n        try {\n            // SEPARATES Audio-Element für Lacher (nicht global!)\n            const laughterAudio = new Audio(randomLaughter);\n            laughterAudio.volume = 0.7; // Etwas leiser als Voice-Overs\n            laughterAudio.play().catch((err)=>{\n                console.log(\"Lacher-Audio autoplay verhindert:\", err);\n            });\n            console.log(\"\\uD83E\\uDD23 Lacher abgespielt:\", randomLaughter);\n        } catch (error) {\n            console.error(\"Lacher-Audio-Fehler:\", error);\n        }\n    };\n    // Character antippen - Rotation, Emotion-Wechsel UND Lachen\n    const handleCharacterClick = ()=>{\n        // Zu laughing oder excited wechseln, aber NIEMALS die aktuelle Emotion\n        const happyEmotions = [\n            \"laughing\",\n            \"excited\"\n        ];\n        let randomHappyEmotion;\n        // Andere Emotion wählen als die aktuelle\n        if (currentEmotion === \"laughing\") {\n            randomHappyEmotion = \"excited\";\n        } else if (currentEmotion === \"excited\") {\n            randomHappyEmotion = \"laughing\";\n        } else {\n            // Wenn weder laughing noch excited, zufällig wählen\n            randomHappyEmotion = happyEmotions[Math.floor(Math.random() * happyEmotions.length)];\n        }\n        changeEmotion(randomHappyEmotion, false); // Mit Flip-Animation\n        setLastEmotionChangeTime(Date.now()); // Cooldown-Timer auch bei direktem Character-Klick setzen\n        // Zufälliges Lachen abspielen (parallel zu Voice-Overs)\n        playRandomLaughter();\n        // Callback für Emotion-Änderung\n        if (onEmotionChange) {\n            onEmotionChange(randomHappyEmotion);\n        }\n    };\n    // Initial Fly-In Animation starten - NUR EINMAL in der gesamten App-Laufzeit\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!characterInitialized) {\n            console.log(\"\\uD83C\\uDFAD Character FIRST TIME INITIALIZATION\");\n            characterInitialized = true; // Setze statische Variable\n            // Nach kurzer Verzögerung Character reinfliegen lassen\n            const loadTimer = setTimeout(()=>{\n                console.log(\"\\uD83C\\uDFAD Setting hasLoaded to true\");\n                setHasLoaded(true);\n            }, 300);\n            return ()=>clearTimeout(loadTimer);\n        } else {\n            console.log(\"\\uD83C\\uDFAD Character ALREADY INITIALIZED - setting hasLoaded immediately\");\n            setHasLoaded(true); // Bei Re-Render sofort auf loaded setzen\n        }\n    }, []);\n    // Context-Änderungen überwachen - mit Ref um doppelte Aufrufe zu verhindern\n    const lastContextRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (currentContext && currentContext !== lastContextRef.current) {\n            console.log(\"\\uD83C\\uDFAD Processing NEW context: '\".concat(currentContext, \"'\"));\n            lastContextRef.current = currentContext;\n            loadContextEmotions(currentContext);\n        }\n    }, [\n        currentContext\n    ]);\n    // Cleanup Timer\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        return ()=>{\n            if (autoResetTimer.current) clearTimeout(autoResetTimer.current);\n            if (emotionChangeTimer.current) clearTimeout(emotionChangeTimer.current);\n        };\n    }, []);\n    // Preload image via Base64 cache, but do not use it for rendering\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!selectedVariant) return;\n        (0,_utils_assetCache__WEBPACK_IMPORTED_MODULE_3__.getCachedAsset)(selectedVariant).catch(()=>{});\n    }, [\n        selectedVariant\n    ]);\n    // Track loading state for the real image\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        let didCancel = false;\n        let fallbackTimer;\n        setImgLoaded(false);\n        if (selectedVariant) {\n            fallbackTimer = setTimeout(()=>{\n                if (!didCancel) setImgLoaded(true);\n            }, 500);\n        }\n        return ()=>{\n            didCancel = true;\n            if (fallbackTimer) clearTimeout(fallbackTimer);\n        };\n    }, [\n        selectedVariant\n    ]);\n    // Animation-Klassen bestimmen\n    const getAnimationClasses = ()=>{\n        let classes = \"character-image\";\n        // Initial Fly-In Animation beim ersten Laden\n        if (!hasLoaded) {\n            classes += \" character-fly-in\";\n            console.log(\"\\uD83C\\uDFA8 CSS Classes: \".concat(classes, \" (fly-in)\"));\n            return classes;\n        }\n        // Rotation-Animation hat Priorität\n        if (rotationPhase === \"out\") {\n            classes += \" character-rotate-out\";\n            console.log(\"\\uD83C\\uDFA8 CSS Classes: \".concat(classes, \" (rotating OUT)\"));\n        } else if (rotationPhase === \"in\") {\n            classes += \" character-rotate-in\";\n            console.log(\"\\uD83C\\uDFA8 CSS Classes: \".concat(classes, \" (rotating IN)\"));\n        } else if (rotationPhase === \"idle\" && !isRotating) {\n            // Subtile Loop-Animation nur wenn wirklich idle\n            classes += \" character-subtle-animation\";\n            console.log(\"\\uD83C\\uDFA8 CSS Classes: \".concat(classes, \" (subtle idle)\"));\n        } else {\n            console.log(\"\\uD83C\\uDFA8 CSS Classes: \".concat(classes, \" (no extra animation)\"));\n        }\n        return classes;\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"character-container\",\n        onClick: handleCharacterClick,\n        title: \"Character antippen f\\xfcr Emotionen!\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n            src: imgSrc,\n            alt: \"Character \".concat(currentEmotion),\n            width: 120,\n            height: 150,\n            className: getAnimationClasses(),\n            style: {\n                objectFit: \"contain\",\n                position: \"relative\",\n                zIndex: 1,\n                opacity: imgLoaded ? 1 : 0,\n                transition: \"opacity 0.2s\"\n            },\n            onLoad: ()=>setImgLoaded(true),\n            onError: ()=>setImgLoaded(true)\n        }, void 0, false, {\n            fileName: \"D:\\\\gitrepros\\\\Vorschulkinder Lexikon\\\\components\\\\Character.js\",\n            lineNumber: 363,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"D:\\\\gitrepros\\\\Vorschulkinder Lexikon\\\\components\\\\Character.js\",\n        lineNumber: 358,\n        columnNumber: 5\n    }, undefined);\n};\n_s(Character, \"Ud3c6ouTSDCcbMKir0SEd/xuaHc=\");\n_c = Character;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Character); // Cache-Refresh: Updated Character Animation and removed isBouncing \nvar _c;\n$RefreshReg$(_c, \"Character\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QixNQUFNO1lBQ2pDdUYsV0FBVztZQUNYbEMsUUFBUUMsR0FBRyxDQUFDLDZCQUEyQixPQUFSaUMsU0FBUTtRQUN6QyxPQUFPLElBQUl2RixrQkFBa0IsVUFBVSxDQUFDRixZQUFZO1lBQ2xELGdEQUFnRDtZQUNoRHlGLFdBQVc7WUFDWGxDLFFBQVFDLEdBQUcsQ0FBQyw2QkFBMkIsT0FBUmlDLFNBQVE7UUFDekMsT0FBTztZQUNMbEMsUUFBUUMsR0FBRyxDQUFDLDZCQUEyQixPQUFSaUMsU0FBUTtRQUN6QztRQUVBLE9BQU9BO0lBQ1Q7SUFFQSxxQkFDRSw4REFBQ0M7UUFDQ0MsV0FBVTtRQUNWQyxTQUFTYjtRQUNUYyxPQUFNO2tCQUVOLDRFQUFDQztZQUNDQyxLQUFLcEU7WUFDTHFFLEtBQUssYUFBNEIsT0FBZmxHO1lBQ2xCbUcsT0FBTztZQUNQQyxRQUFRO1lBQ1JQLFdBQVdIO1lBQ1hXLE9BQU87Z0JBQUVDLFdBQVc7Z0JBQVdDLFVBQVU7Z0JBQVlDLFFBQVE7Z0JBQUdDLFNBQVM5RSxZQUFZLElBQUk7Z0JBQUcrRSxZQUFZO1lBQWU7WUFDdkhDLFFBQVEsSUFBTS9FLGFBQWE7WUFDM0JnRixTQUFTLElBQU1oRixhQUFhOzs7Ozs7Ozs7OztBQUlwQztHQTdXTS9CO0tBQUFBO0FBK1dOLCtEQUFlQSxTQUFTQSxFQUFDLENBQ3pCLHFFQUFxRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0NoYXJhY3Rlci5qcz9lMjdmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBJbWFnZSBmcm9tICduZXh0L2ltYWdlJztcbmltcG9ydCB7IGdldENhY2hlZEFzc2V0LCBnZXRDYWNoZWRBc3NldEFzQmxvYiB9IGZyb20gJy4uL3V0aWxzL2Fzc2V0Q2FjaGUnO1xuXG4vLyBTdGF0aXNjaGUgVmFyaWFibGUgdW0gc2ljaGVyenVzdGVsbGVuIGRhc3MgQ2hhcmFjdGVyIG51ciBFSU5NQUwgaW5pdGlhbGlzaWVydCB3aXJkXG5sZXQgY2hhcmFjdGVySW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuLy8gRW50ZmVybmUgZGllIEhpbGZzZnVua3Rpb24gZ2V0Q2hhcmFjdGVySW1hZ2VVcmxcblxuY29uc3QgQ2hhcmFjdGVyID0gKHsgY3VycmVudENvbnRleHQgPSAnaWRsZScsIG9uRW1vdGlvbkNoYW5nZSB9KSA9PiB7XG4gIGNvbnN0IFtjdXJyZW50RW1vdGlvbiwgc2V0Q3VycmVudEVtb3Rpb25dID0gdXNlU3RhdGUoJ2lkbGUnKTtcbiAgY29uc3QgW2lzUm90YXRpbmcsIHNldElzUm90YXRpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbcm90YXRpb25QaGFzZSwgc2V0Um90YXRpb25QaGFzZV0gPSB1c2VTdGF0ZSgnaWRsZScpOyAvLyAnaWRsZScsICdvdXQnLCAnaW4nXG4gIGNvbnN0IFthdmFpbGFibGVFbW90aW9ucywgc2V0QXZhaWxhYmxlRW1vdGlvbnNdID0gdXNlU3RhdGUoWydpZGxlJywgJ2N1cmlvdXMnXSk7XG4gIGNvbnN0IFtoYXNMb2FkZWQsIHNldEhhc0xvYWRlZF0gPSB1c2VTdGF0ZShjaGFyYWN0ZXJJbml0aWFsaXplZCk7IC8vIEbDvHIgaW5pdGlhbGUgRmx5LUluIEFuaW1hdGlvbiAtIGVpbm1hbCBmw7xyIGltbWVyXG4gIGNvbnN0IFtsYXN0UHJvY2Vzc2VkQ29udGV4dCwgc2V0TGFzdFByb2Nlc3NlZENvbnRleHRdID0gdXNlU3RhdGUobnVsbCk7IC8vIFZlcmhpbmRlcnQgbWVocmZhY2hlIEVtb3Rpb24tV2VjaHNlbFxuICBjb25zdCBbbGFzdEVtb3Rpb25DaGFuZ2VUaW1lLCBzZXRMYXN0RW1vdGlvbkNoYW5nZVRpbWVdID0gdXNlU3RhdGUoMCk7IC8vIENvb2xkb3duIGbDvHIgRW1vdGlvbi1DaGFuZ2VzXG4gIFxuICBjb25zdCBhdXRvUmVzZXRUaW1lciA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgZW1vdGlvbkNoYW5nZVRpbWVyID0gdXNlUmVmKG51bGwpO1xuXG4gIC8vIENoYXJhY3Rlci1CaWxkZXItVmFyaWFudGVuIGRlZmluaWVyZW5cbiAgY29uc3QgY2hhcmFjdGVyVmFyaWFudHMgPSB7XG4gICAgaWRsZTogW1xuICAgICAgJy9DaGFyYWN0ZXJzL0NoYXJhY3Rlci1pZGxlLnBuZycsXG4gICAgICAnL0NoYXJhY3RlcnMvQ2hhcmFjdGVyLWlkbGUtMi5wbmcnLFxuICAgICAgJy9DaGFyYWN0ZXJzL0NoYXJhY3Rlci1pZGxlLTMucG5nJ1xuICAgIF0sXG4gICAgZXhjaXRlZDogW1xuICAgICAgJy9DaGFyYWN0ZXJzL0NoYXJhY3Rlci1leGNpdGVkLnBuZycsXG4gICAgICAnL0NoYXJhY3RlcnMvQ2hhcmFjdGVyLWV4Y2l0ZWQtMi5wbmcnLFxuICAgICAgJy9DaGFyYWN0ZXJzL0NoYXJhY3Rlci1leGNpdGVkLTMucG5nJ1xuICAgIF0sXG4gICAgY3VyaW91czogW1xuICAgICAgJy9DaGFyYWN0ZXJzL0NoYXJhY3Rlci1jdXJpb3VzLnBuZycsXG4gICAgICAnL0NoYXJhY3RlcnMvQ2hhcmFjdGVyLWN1cmlvdXMtMi5wbmcnLFxuICAgICAgJy9DaGFyYWN0ZXJzL0NoYXJhY3Rlci1jdXJpb3VzLTMucG5nJ1xuICAgIF0sXG4gICAgc3VycHJpc2VkOiBbXG4gICAgICAnL0NoYXJhY3RlcnMvQ2hhcmFjdGVyLXN1cnByaXNlZC5wbmcnLFxuICAgICAgJy9DaGFyYWN0ZXJzL0NoYXJhY3Rlci1zdXJwcmlzZWQtMi5wbmcnLFxuICAgICAgJy9DaGFyYWN0ZXJzL0NoYXJhY3Rlci1zdXJwcmlzZWQtMy5wbmcnXG4gICAgXSxcbiAgICB0aGlua2luZzogW1xuICAgICAgJy9DaGFyYWN0ZXJzL0NoYXJhY3Rlci10aGlua2luZy5wbmcnLFxuICAgICAgJy9DaGFyYWN0ZXJzL0NoYXJhY3Rlci10aGlua2luZy0yLnBuZycsXG4gICAgICAnL0NoYXJhY3RlcnMvQ2hhcmFjdGVyLXRoaW5raW5nLTMucG5nJ1xuICAgIF0sXG4gICAgbGF1Z2hpbmc6IFtcbiAgICAgICcvQ2hhcmFjdGVycy9DaGFyYWN0ZXItbGF1Z2hpbmcucG5nJyxcbiAgICAgICcvQ2hhcmFjdGVycy9DaGFyYWN0ZXItbGF1Z2hpbmctMi5wbmcnXG4gICAgXSxcbiAgICBleHBsb3Jpbmc6IFtcbiAgICAgICcvQ2hhcmFjdGVycy9DaGFyYWN0ZXItZXhjaXRlZC5wbmcnLFxuICAgICAgJy9DaGFyYWN0ZXJzL0NoYXJhY3Rlci1leGNpdGVkLTIucG5nJyxcbiAgICAgICcvQ2hhcmFjdGVycy9DaGFyYWN0ZXItZXhjaXRlZC0zLnBuZydcbiAgICBdLFxuICAgIHNjYXJlZDogW1xuICAgICAgJy9DaGFyYWN0ZXJzL0NoYXJhY3Rlci1zdXJwcmlzZWQucG5nJyxcbiAgICAgICcvQ2hhcmFjdGVycy9DaGFyYWN0ZXItc3VycHJpc2VkLTIucG5nJyxcbiAgICAgICcvQ2hhcmFjdGVycy9DaGFyYWN0ZXItc3VycHJpc2VkLTMucG5nJ1xuICAgIF0sXG4gIH07XG5cbiAgLy8gU3RhdGUgZsO8ciBnZXfDpGhsdGUgVmFyaWFudGUgcHJvIEVtb3Rpb25cbiAgY29uc3QgW3NlbGVjdGVkVmFyaWFudCwgc2V0U2VsZWN0ZWRWYXJpYW50XSA9IHVzZVN0YXRlKCcvQ2hhcmFjdGVycy9DaGFyYWN0ZXItaWRsZS5wbmcnKTtcbiAgY29uc3QgW2ltZ0xvYWRlZCwgc2V0SW1nTG9hZGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2ltZ1NyYywgc2V0SW1nU3JjXSA9IHVzZVN0YXRlKCcvQ2hhcmFjdGVycy9DaGFyYWN0ZXItaWRsZS5wbmcnKTtcblxuICAvLyBXaGVuZXZlciBzZWxlY3RlZFZhcmlhbnQgY2hhbmdlcywgdHJ5IHRvIGxvYWQgZnJvbSBjYWNoZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCBvYmplY3RVcmw7XG4gICAgbGV0IGlzTW91bnRlZCA9IHRydWU7XG4gICAgaWYgKCFzZWxlY3RlZFZhcmlhbnQpIHJldHVybjtcbiAgICBnZXRDYWNoZWRBc3NldEFzQmxvYihzZWxlY3RlZFZhcmlhbnQpXG4gICAgICAudGhlbihibG9iID0+IHtcbiAgICAgICAgaWYgKGJsb2IgJiYgaXNNb3VudGVkKSB7XG4gICAgICAgICAgb2JqZWN0VXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgICAgICBzZXRJbWdTcmMob2JqZWN0VXJsKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc01vdW50ZWQpIHtcbiAgICAgICAgICBzZXRJbWdTcmMoc2VsZWN0ZWRWYXJpYW50KTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoKSA9PiB7XG4gICAgICAgIGlmIChpc01vdW50ZWQpIHNldEltZ1NyYyhzZWxlY3RlZFZhcmlhbnQpO1xuICAgICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlzTW91bnRlZCA9IGZhbHNlO1xuICAgICAgaWYgKG9iamVjdFVybCkgVVJMLnJldm9rZU9iamVjdFVSTChvYmplY3RVcmwpO1xuICAgIH07XG4gIH0sIFtzZWxlY3RlZFZhcmlhbnRdKTtcblxuICAvLyBadWbDpGxsaWdlIFZhcmlhbnRlIGbDvHIgRW1vdGlvbiB3w6RobGVuIHVuZCBzcGVpY2hlcm4gKE5JRU1BTFMgZGllIGdsZWljaGUpXG4gIGNvbnN0IHNlbGVjdFZhcmlhbnRGb3JFbW90aW9uID0gKGVtb3Rpb24pID0+IHtcbiAgICBjb25zdCB2YXJpYW50cyA9IGNoYXJhY3RlclZhcmlhbnRzW2Vtb3Rpb25dIHx8IGNoYXJhY3RlclZhcmlhbnRzLmlkbGU7XG4gICAgXG4gICAgLy8gV2VubiBudXIgZWluZSBWYXJpYW50ZSB2b3JoYW5kZW4sIGRpZXNlIG5laG1lblxuICAgIGlmICh2YXJpYW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IHZhcmlhbnQgPSB2YXJpYW50c1swXTtcbiAgICAgIHNldFNlbGVjdGVkVmFyaWFudCh2YXJpYW50KTtcbiAgICAgIHJldHVybiB2YXJpYW50O1xuICAgIH1cbiAgICBcbiAgICAvLyBBa3R1ZWxsZSBWYXJpYW50ZSByYXVzZmlsdGVybiB1bSBXaWVkZXJob2x1bmcgenUgdmVybWVpZGVuXG4gICAgY29uc3Qgb3RoZXJWYXJpYW50cyA9IHZhcmlhbnRzLmZpbHRlcih2YXJpYW50ID0+IHZhcmlhbnQgIT09IHNlbGVjdGVkVmFyaWFudCk7XG4gICAgXG4gICAgLy8gRmFsbHMgYWxsZSBWYXJpYW50ZW4gZGllIGdsZWljaGUgc2luZCAoc29sbHRlIG5pY2h0IHBhc3NpZXJlbiksIGVyc3RlIG5laG1lblxuICAgIGlmIChvdGhlclZhcmlhbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc3QgdmFyaWFudCA9IHZhcmlhbnRzWzBdO1xuICAgICAgc2V0U2VsZWN0ZWRWYXJpYW50KHZhcmlhbnQpO1xuICAgICAgcmV0dXJuIHZhcmlhbnQ7XG4gICAgfVxuICAgIFxuICAgIC8vIFp1ZsOkbGxpZ2UgYW5kZXJlIFZhcmlhbnRlIHfDpGhsZW5cbiAgICBjb25zdCByYW5kb21WYXJpYW50ID0gb3RoZXJWYXJpYW50c1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBvdGhlclZhcmlhbnRzLmxlbmd0aCldO1xuICAgIHNldFNlbGVjdGVkVmFyaWFudChyYW5kb21WYXJpYW50KTtcbiAgICByZXR1cm4gcmFuZG9tVmFyaWFudDtcbiAgfTtcblxuICAvLyBadWbDpGxsaWdlIEVtb3Rpb24gYXVzIHZlcmbDvGdiYXJlbiBFbW90aW9uZW4gd8OkaGxlblxuICBjb25zdCBnZXRSYW5kb21FbW90aW9uID0gKGVtb3Rpb25zID0gYXZhaWxhYmxlRW1vdGlvbnMpID0+IHtcbiAgICBjb25zdCBmaWx0ZXJlZCA9IGVtb3Rpb25zLmZpbHRlcihlID0+IGUgIT09IGN1cnJlbnRFbW90aW9uKTtcbiAgICBpZiAoZmlsdGVyZWQubGVuZ3RoID09PSAwKSByZXR1cm4gZW1vdGlvbnNbMF07XG4gICAgcmV0dXJuIGZpbHRlcmVkW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGZpbHRlcmVkLmxlbmd0aCldO1xuICB9O1xuXG4gIC8vIEVtb3Rpb24tV2VjaHNlbCBtaXQgdXJzcHLDvG5nbGljaGVyIEZsaXAtQW5pbWF0aW9uXG4gIGNvbnN0IGNoYW5nZUVtb3Rpb24gPSAobmV3RW1vdGlvbiwgaW1tZWRpYXRlID0gZmFsc2UpID0+IHtcbiAgICBjb25zb2xlLmxvZyhg8J+OrSBFbW90aW9uIGNoYW5nZTogJHtjdXJyZW50RW1vdGlvbn0g4oaSICR7bmV3RW1vdGlvbn0gKGltbWVkaWF0ZTogJHtpbW1lZGlhdGV9KWApO1xuICAgIFxuICAgIGlmIChuZXdFbW90aW9uID09PSBjdXJyZW50RW1vdGlvbikge1xuICAgICAgY29uc29sZS5sb2coYPCfjq0gU2FtZSBlbW90aW9uLCBza2lwcGluZ2ApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBpZiAoaW1tZWRpYXRlKSB7XG4gICAgICAvLyBEaXJla3RlciBXZWNoc2VsIG9obmUgQW5pbWF0aW9uXG4gICAgICBjb25zb2xlLmxvZyhg8J+OrSBJbW1lZGlhdGUgY2hhbmdlIHRvICR7bmV3RW1vdGlvbn1gKTtcbiAgICAgIHNldEN1cnJlbnRFbW90aW9uKG5ld0Vtb3Rpb24pO1xuICAgICAgc2VsZWN0VmFyaWFudEZvckVtb3Rpb24obmV3RW1vdGlvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIEZsaXAtQW5pbWF0aW9uOiBSYXVzIC0+IEJpbGQgd2VjaHNlbG4gLT4gUmVpblxuICAgIGNvbnNvbGUubG9nKGDwn46tIFN0YXJ0aW5nIGZsaXAgYW5pbWF0aW9uOiBvdXQg4oaSIGNoYW5nZSDihpIgaW5gKTtcbiAgICBzZXRJc1JvdGF0aW5nKHRydWUpO1xuICAgIHNldFJvdGF0aW9uUGhhc2UoJ291dCcpO1xuICAgIFxuICAgIC8vIE5hY2ggUmF1cy1BbmltYXRpb24gKDIwMG1zKTogQmlsZCB3ZWNoc2VsblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgY29uc29sZS5sb2coYPCfjq0gRmxpcCBhbmltYXRpb246IENoYW5naW5nIGltYWdlIHRvICR7bmV3RW1vdGlvbn1gKTtcbiAgICAgIHNldEN1cnJlbnRFbW90aW9uKG5ld0Vtb3Rpb24pO1xuICAgICAgc2VsZWN0VmFyaWFudEZvckVtb3Rpb24obmV3RW1vdGlvbik7XG4gICAgICBzZXRSb3RhdGlvblBoYXNlKCdpbicpO1xuICAgICAgXG4gICAgICAvLyBOYWNoIFJlaW4tQW5pbWF0aW9uICgyMDBtcyk6IEFuaW1hdGlvbiBiZWVuZGVuXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coYPCfjq0gRmxpcCBhbmltYXRpb246IENvbXBsZXRlIWApO1xuICAgICAgICBzZXRSb3RhdGlvblBoYXNlKCdpZGxlJyk7XG4gICAgICAgIHNldElzUm90YXRpbmcoZmFsc2UpO1xuICAgICAgfSwgMjAwKTtcbiAgICB9LCAyMDApO1xuICB9O1xuXG4gIC8vIEF1dG8tUmVzZXQgZW50ZmVybnQgLSBDaGFyYWN0ZXIgd2VjaHNlbHQgbnVyIGJlaSBJbnRlcmFrdGlvbmVuXG5cbiAgLy8gQ29udGV4dC1hYmjDpG5naWdlIEVtb3Rpb25lbiBsYWRlblxuICBjb25zdCBsb2FkQ29udGV4dEVtb3Rpb25zID0gYXN5bmMgKGNvbnRleHQpID0+IHtcbiAgICBjb25zb2xlLmxvZyhg8J+OrSBsb2FkQ29udGV4dEVtb3Rpb25zIGNhbGxlZCB3aXRoIGNvbnRleHQ6ICcke2NvbnRleHR9JyAobGFzdFByb2Nlc3NlZDogJyR7bGFzdFByb2Nlc3NlZENvbnRleHR9JylgKTtcbiAgICB0cnkge1xuICAgICAgLy8gU3RhdHQgQVBJOiBEZWZpbmllcmUgZGllIEVtb3Rpb25zLUxvZ2lrIGNsaWVudHNlaXRpZyBvZGVyIGxhZGUgYXVzIHN0YXRpc2NoZXIgRGF0ZWlcbiAgICAgIC8vIEJlaXNwaWVsOiBNYXBwaW5nIHZvbiBDb250ZXh0IHp1IEVtb3Rpb25zXG4gICAgICBjb25zdCBjb250ZXh0RW1vdGlvbk1hcCA9IHtcbiAgICAgICAgaWRsZTogWydpZGxlJywgJ2N1cmlvdXMnXSxcbiAgICAgICAgbWFpbjogWydleGNpdGVkJywgJ2N1cmlvdXMnLCAnaWRsZSddLFxuICAgICAgICBjYXRlZ29yeTogWydjdXJpb3VzJywgJ3RoaW5raW5nJywgJ2V4Y2l0ZWQnXSxcbiAgICAgICAgYW5pbWFsczogWydleGNpdGVkJywgJ3N1cnByaXNlZCcsICdsYXVnaGluZyddLFxuICAgICAgICBkZWZhdWx0OiBbJ2lkbGUnLCAnY3VyaW91cycsICdleGNpdGVkJywgJ3N1cnByaXNlZCcsICd0aGlua2luZycsICdsYXVnaGluZyddXG4gICAgICB9O1xuICAgICAgY29uc3QgZW1vdGlvbnMgPSBjb250ZXh0RW1vdGlvbk1hcFtjb250ZXh0XSB8fCBjb250ZXh0RW1vdGlvbk1hcC5kZWZhdWx0O1xuICAgICAgc2V0QXZhaWxhYmxlRW1vdGlvbnMoZW1vdGlvbnMpO1xuICAgICAgLy8gRGVyIFJlc3QgYmxlaWJ0IGdsZWljaCB3aWUgdm9yaGVyXG4gICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IHRpbWVTaW5jZUxhc3RDaGFuZ2UgPSBub3cgLSBsYXN0RW1vdGlvbkNoYW5nZVRpbWU7XG4gICAgICAgIGNvbnN0IEVNT1RJT05fQ09PTERPV04gPSAyMDAwOyAvLyAyIFNla3VuZGVuIENvb2xkb3duXG4gICAgICAgIGNvbnNvbGUubG9nKGDwn46tIENvbnRleHQgY2hlY2s6IGNvbnRleHQ9JHtjb250ZXh0fSwgbGFzdFByb2Nlc3NlZD0ke2xhc3RQcm9jZXNzZWRDb250ZXh0fSwgY29vbGRvd249JHt0aW1lU2luY2VMYXN0Q2hhbmdlfW1zYCk7XG4gICAgICAgIGlmIChjb250ZXh0ICE9PSAnaWRsZScgJiYgY29udGV4dCAhPT0gbGFzdFByb2Nlc3NlZENvbnRleHQgJiYgdGltZVNpbmNlTGFzdENoYW5nZSA+PSBFTU9USU9OX0NPT0xET1dOKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYPCfjq0gVFJJR0dFUklORyBlbW90aW9uIGNoYW5nZSBmb3IgY29udGV4dCAnJHtjb250ZXh0fSdgKTtcbiAgICAgICAgY29uc3QgcmFuZG9tRW1vdGlvbiA9IGVtb3Rpb25zW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGVtb3Rpb25zLmxlbmd0aCldO1xuICAgICAgICAgIGNoYW5nZUVtb3Rpb24ocmFuZG9tRW1vdGlvbiwgZmFsc2UpOyAvLyBNaXQgRmxpcC1BbmltYXRpb25cbiAgICAgICAgICBzZXRMYXN0UHJvY2Vzc2VkQ29udGV4dChjb250ZXh0KTsgLy8gTWVya2UgZGFzcyB3aXIgZGllc2VuIENvbnRleHQgc2Nob24gdmVyYXJiZWl0ZXQgaGFiZW5cbiAgICAgICAgICBzZXRMYXN0RW1vdGlvbkNoYW5nZVRpbWUobm93KTsgLy8gU2V0emUgQ29vbGRvd24tVGltZXJcbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0ID09PSBsYXN0UHJvY2Vzc2VkQ29udGV4dCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn46tIEJMT0NLRUQ6IENvbnRleHQgJyR7Y29udGV4dH0nIGFscmVhZHkgcHJvY2Vzc2VkYCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGltZVNpbmNlTGFzdENoYW5nZSA8IEVNT1RJT05fQ09PTERPV04pIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhg8J+OrSBCTE9DS0VEOiBDb29sZG93biBhY3RpdmUgKCR7dGltZVNpbmNlTGFzdENoYW5nZX1tcyA8ICR7RU1PVElPTl9DT09MRE9XTn1tcylgKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0ID09PSAnaWRsZScpIHtcbiAgICAgICAgICAvLyBCZWkgaWRsZS1Db250ZXh0OiBSZXNldCBsYXN0UHJvY2Vzc2VkQ29udGV4dCBmw7xyIG7DpGNoc3RlIEludGVyYWt0aW9uIChhYmVyIGtlaW4gQ29vbGRvd24gUmVzZXQpXG4gICAgICAgICAgY29uc29sZS5sb2coYPCfjq0gUkVTRVQ6IElkbGUgY29udGV4dCwgY2xlYXJpbmcgbGFzdFByb2Nlc3NlZENvbnRleHRgKTtcbiAgICAgICAgICBzZXRMYXN0UHJvY2Vzc2VkQ29udGV4dChudWxsKTtcbiAgICAgICAgICAvLyBDaGFyYWN0ZXIgd2lyZCBOSUNIVCBuZXUgaW5zdGFuemllcnQsIG51ciBoYXNMb2FkZWQgYmxlaWJ0IHRydWVcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBjb250ZXh0IGVtb3Rpb25zOicsIGVycm9yKTtcbiAgICAgIHNldEF2YWlsYWJsZUVtb3Rpb25zKFsnaWRsZScsICdjdXJpb3VzJ10pO1xuICAgIH1cbiAgfTtcblxuICAvLyBadWbDpGxsaWdlcyBMYWNoZW4gYWJzcGllbGVuIChvaG5lIFZvaWNlLU92ZXJzIHp1IHVudGVyYnJlY2hlbilcbiAgY29uc3QgcGxheVJhbmRvbUxhdWdodGVyID0gKCkgPT4ge1xuICAgIGNvbnN0IGxhdWdodGVyRmlsZXMgPSBbXG4gICAgICAnL2F1ZGlvL0xhdWdoaW5nS2lkL2xhdWdoaW5nLTEud2F2JyxcbiAgICAgICcvYXVkaW8vTGF1Z2hpbmdLaWQvbGF1Z2hpbmctMi53YXYnLFxuICAgICAgJy9hdWRpby9MYXVnaGluZ0tpZC9sYXVnaGluZy0zLndhdicsXG4gICAgICAnL2F1ZGlvL0xhdWdoaW5nS2lkL2xhdWdoaW5nLTQud2F2JyxcbiAgICAgICcvYXVkaW8vTGF1Z2hpbmdLaWQvbGF1Z2hpbmctNS53YXYnLFxuICAgICAgJy9hdWRpby9MYXVnaGluZ0tpZC9sYXVnaGluZy02LndhdicsXG4gICAgICAnL2F1ZGlvL0xhdWdoaW5nS2lkL2xhdWdoaW5nLTcud2F2J1xuICAgIF07XG4gICAgXG4gICAgLy8gWnVmw6RsbGlnZSBMYWNoZXItRGF0ZWkgYXVzd8OkaGxlblxuICAgIGNvbnN0IHJhbmRvbUxhdWdodGVyID0gbGF1Z2h0ZXJGaWxlc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBsYXVnaHRlckZpbGVzLmxlbmd0aCldO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBTRVBBUkFURVMgQXVkaW8tRWxlbWVudCBmw7xyIExhY2hlciAobmljaHQgZ2xvYmFsISlcbiAgICAgIGNvbnN0IGxhdWdodGVyQXVkaW8gPSBuZXcgQXVkaW8ocmFuZG9tTGF1Z2h0ZXIpO1xuICAgICAgbGF1Z2h0ZXJBdWRpby52b2x1bWUgPSAwLjc7IC8vIEV0d2FzIGxlaXNlciBhbHMgVm9pY2UtT3ZlcnNcbiAgICAgIFxuICAgICAgbGF1Z2h0ZXJBdWRpby5wbGF5KCkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ0xhY2hlci1BdWRpbyBhdXRvcGxheSB2ZXJoaW5kZXJ0OicsIGVycik7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ/CfpKMgTGFjaGVyIGFiZ2VzcGllbHQ6JywgcmFuZG9tTGF1Z2h0ZXIpO1xuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0xhY2hlci1BdWRpby1GZWhsZXI6JywgZXJyb3IpO1xuICAgIH1cbiAgfTtcblxuICAvLyBDaGFyYWN0ZXIgYW50aXBwZW4gLSBSb3RhdGlvbiwgRW1vdGlvbi1XZWNoc2VsIFVORCBMYWNoZW5cbiAgY29uc3QgaGFuZGxlQ2hhcmFjdGVyQ2xpY2sgPSAoKSA9PiB7XG4gICAgLy8gWnUgbGF1Z2hpbmcgb2RlciBleGNpdGVkIHdlY2hzZWxuLCBhYmVyIE5JRU1BTFMgZGllIGFrdHVlbGxlIEVtb3Rpb25cbiAgICBjb25zdCBoYXBweUVtb3Rpb25zID0gWydsYXVnaGluZycsICdleGNpdGVkJ107XG4gICAgbGV0IHJhbmRvbUhhcHB5RW1vdGlvbjtcbiAgICBcbiAgICAvLyBBbmRlcmUgRW1vdGlvbiB3w6RobGVuIGFscyBkaWUgYWt0dWVsbGVcbiAgICBpZiAoY3VycmVudEVtb3Rpb24gPT09ICdsYXVnaGluZycpIHtcbiAgICAgIHJhbmRvbUhhcHB5RW1vdGlvbiA9ICdleGNpdGVkJztcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRFbW90aW9uID09PSAnZXhjaXRlZCcpIHtcbiAgICAgIHJhbmRvbUhhcHB5RW1vdGlvbiA9ICdsYXVnaGluZyc7ICBcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV2VubiB3ZWRlciBsYXVnaGluZyBub2NoIGV4Y2l0ZWQsIHp1ZsOkbGxpZyB3w6RobGVuXG4gICAgICByYW5kb21IYXBweUVtb3Rpb24gPSBoYXBweUVtb3Rpb25zW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGhhcHB5RW1vdGlvbnMubGVuZ3RoKV07XG4gICAgfVxuICAgIFxuICAgIGNoYW5nZUVtb3Rpb24ocmFuZG9tSGFwcHlFbW90aW9uLCBmYWxzZSk7IC8vIE1pdCBGbGlwLUFuaW1hdGlvblxuICAgIHNldExhc3RFbW90aW9uQ2hhbmdlVGltZShEYXRlLm5vdygpKTsgLy8gQ29vbGRvd24tVGltZXIgYXVjaCBiZWkgZGlyZWt0ZW0gQ2hhcmFjdGVyLUtsaWNrIHNldHplblxuICAgIFxuICAgIC8vIFp1ZsOkbGxpZ2VzIExhY2hlbiBhYnNwaWVsZW4gKHBhcmFsbGVsIHp1IFZvaWNlLU92ZXJzKVxuICAgIHBsYXlSYW5kb21MYXVnaHRlcigpO1xuICAgIFxuICAgIC8vIENhbGxiYWNrIGbDvHIgRW1vdGlvbi3DhG5kZXJ1bmdcbiAgICBpZiAob25FbW90aW9uQ2hhbmdlKSB7XG4gICAgICBvbkVtb3Rpb25DaGFuZ2UocmFuZG9tSGFwcHlFbW90aW9uKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gSW5pdGlhbCBGbHktSW4gQW5pbWF0aW9uIHN0YXJ0ZW4gLSBOVVIgRUlOTUFMIGluIGRlciBnZXNhbXRlbiBBcHAtTGF1ZnplaXRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWNoYXJhY3RlckluaXRpYWxpemVkKSB7XG4gICAgICBjb25zb2xlLmxvZyhg8J+OrSBDaGFyYWN0ZXIgRklSU1QgVElNRSBJTklUSUFMSVpBVElPTmApO1xuICAgICAgY2hhcmFjdGVySW5pdGlhbGl6ZWQgPSB0cnVlOyAvLyBTZXR6ZSBzdGF0aXNjaGUgVmFyaWFibGVcbiAgICAgIFxuICAgICAgLy8gTmFjaCBrdXJ6ZXIgVmVyesO2Z2VydW5nIENoYXJhY3RlciByZWluZmxpZWdlbiBsYXNzZW5cbiAgICAgIGNvbnN0IGxvYWRUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZyhg8J+OrSBTZXR0aW5nIGhhc0xvYWRlZCB0byB0cnVlYCk7XG4gICAgICAgIHNldEhhc0xvYWRlZCh0cnVlKTtcbiAgICAgIH0sIDMwMCk7XG4gICAgICBcbiAgICAgIHJldHVybiAoKSA9PiBjbGVhclRpbWVvdXQobG9hZFRpbWVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coYPCfjq0gQ2hhcmFjdGVyIEFMUkVBRFkgSU5JVElBTElaRUQgLSBzZXR0aW5nIGhhc0xvYWRlZCBpbW1lZGlhdGVseWApO1xuICAgICAgc2V0SGFzTG9hZGVkKHRydWUpOyAvLyBCZWkgUmUtUmVuZGVyIHNvZm9ydCBhdWYgbG9hZGVkIHNldHplblxuICAgIH1cbiAgfSwgW10pO1xuXG4gIC8vIENvbnRleHQtw4RuZGVydW5nZW4gw7xiZXJ3YWNoZW4gLSBtaXQgUmVmIHVtIGRvcHBlbHRlIEF1ZnJ1ZmUgenUgdmVyaGluZGVyblxuICBjb25zdCBsYXN0Q29udGV4dFJlZiA9IHVzZVJlZihudWxsKTtcbiAgXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGN1cnJlbnRDb250ZXh0ICYmIGN1cnJlbnRDb250ZXh0ICE9PSBsYXN0Q29udGV4dFJlZi5jdXJyZW50KSB7XG4gICAgICBjb25zb2xlLmxvZyhg8J+OrSBQcm9jZXNzaW5nIE5FVyBjb250ZXh0OiAnJHtjdXJyZW50Q29udGV4dH0nYCk7XG4gICAgICBsYXN0Q29udGV4dFJlZi5jdXJyZW50ID0gY3VycmVudENvbnRleHQ7XG4gICAgICBsb2FkQ29udGV4dEVtb3Rpb25zKGN1cnJlbnRDb250ZXh0KTtcbiAgICB9XG4gIH0sIFtjdXJyZW50Q29udGV4dF0pO1xuXG4gIC8vIENsZWFudXAgVGltZXJcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKGF1dG9SZXNldFRpbWVyLmN1cnJlbnQpIGNsZWFyVGltZW91dChhdXRvUmVzZXRUaW1lci5jdXJyZW50KTtcbiAgICAgIGlmIChlbW90aW9uQ2hhbmdlVGltZXIuY3VycmVudCkgY2xlYXJUaW1lb3V0KGVtb3Rpb25DaGFuZ2VUaW1lci5jdXJyZW50KTtcbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgLy8gUHJlbG9hZCBpbWFnZSB2aWEgQmFzZTY0IGNhY2hlLCBidXQgZG8gbm90IHVzZSBpdCBmb3IgcmVuZGVyaW5nXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFzZWxlY3RlZFZhcmlhbnQpIHJldHVybjtcbiAgICBnZXRDYWNoZWRBc3NldChzZWxlY3RlZFZhcmlhbnQpLmNhdGNoKCgpID0+IHt9KTtcbiAgfSwgW3NlbGVjdGVkVmFyaWFudF0pO1xuXG4gIC8vIFRyYWNrIGxvYWRpbmcgc3RhdGUgZm9yIHRoZSByZWFsIGltYWdlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IGRpZENhbmNlbCA9IGZhbHNlO1xuICAgIGxldCBmYWxsYmFja1RpbWVyO1xuICAgIHNldEltZ0xvYWRlZChmYWxzZSk7XG4gICAgaWYgKHNlbGVjdGVkVmFyaWFudCkge1xuICAgICAgZmFsbGJhY2tUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAoIWRpZENhbmNlbCkgc2V0SW1nTG9hZGVkKHRydWUpO1xuICAgICAgfSwgNTAwKTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGRpZENhbmNlbCA9IHRydWU7XG4gICAgICBpZiAoZmFsbGJhY2tUaW1lcikgY2xlYXJUaW1lb3V0KGZhbGxiYWNrVGltZXIpO1xuICAgIH07XG4gIH0sIFtzZWxlY3RlZFZhcmlhbnRdKTtcblxuICAvLyBBbmltYXRpb24tS2xhc3NlbiBiZXN0aW1tZW5cbiAgY29uc3QgZ2V0QW5pbWF0aW9uQ2xhc3NlcyA9ICgpID0+IHtcbiAgICBsZXQgY2xhc3NlcyA9ICdjaGFyYWN0ZXItaW1hZ2UnO1xuICAgIFxuICAgIC8vIEluaXRpYWwgRmx5LUluIEFuaW1hdGlvbiBiZWltIGVyc3RlbiBMYWRlblxuICAgIGlmICghaGFzTG9hZGVkKSB7XG4gICAgICBjbGFzc2VzICs9ICcgY2hhcmFjdGVyLWZseS1pbic7XG4gICAgICBjb25zb2xlLmxvZyhg8J+OqCBDU1MgQ2xhc3NlczogJHtjbGFzc2VzfSAoZmx5LWluKWApO1xuICAgICAgcmV0dXJuIGNsYXNzZXM7XG4gICAgfVxuICAgIFxuICAgIC8vIFJvdGF0aW9uLUFuaW1hdGlvbiBoYXQgUHJpb3JpdMOkdFxuICAgIGlmIChyb3RhdGlvblBoYXNlID09PSAnb3V0Jykge1xuICAgICAgY2xhc3NlcyArPSAnIGNoYXJhY3Rlci1yb3RhdGUtb3V0JztcbiAgICAgIGNvbnNvbGUubG9nKGDwn46oIENTUyBDbGFzc2VzOiAke2NsYXNzZXN9IChyb3RhdGluZyBPVVQpYCk7XG4gICAgfSBlbHNlIGlmIChyb3RhdGlvblBoYXNlID09PSAnaW4nKSB7XG4gICAgICBjbGFzc2VzICs9ICcgY2hhcmFjdGVyLXJvdGF0ZS1pbic7XG4gICAgICBjb25zb2xlLmxvZyhg8J+OqCBDU1MgQ2xhc3NlczogJHtjbGFzc2VzfSAocm90YXRpbmcgSU4pYCk7XG4gICAgfSBlbHNlIGlmIChyb3RhdGlvblBoYXNlID09PSAnaWRsZScgJiYgIWlzUm90YXRpbmcpIHtcbiAgICAgIC8vIFN1YnRpbGUgTG9vcC1BbmltYXRpb24gbnVyIHdlbm4gd2lya2xpY2ggaWRsZVxuICAgICAgY2xhc3NlcyArPSAnIGNoYXJhY3Rlci1zdWJ0bGUtYW5pbWF0aW9uJztcbiAgICAgIGNvbnNvbGUubG9nKGDwn46oIENTUyBDbGFzc2VzOiAke2NsYXNzZXN9IChzdWJ0bGUgaWRsZSlgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coYPCfjqggQ1NTIENsYXNzZXM6ICR7Y2xhc3Nlc30gKG5vIGV4dHJhIGFuaW1hdGlvbilgKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGNsYXNzZXM7XG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IFxuICAgICAgY2xhc3NOYW1lPVwiY2hhcmFjdGVyLWNvbnRhaW5lclwiXG4gICAgICBvbkNsaWNrPXtoYW5kbGVDaGFyYWN0ZXJDbGlja31cbiAgICAgIHRpdGxlPVwiQ2hhcmFjdGVyIGFudGlwcGVuIGbDvHIgRW1vdGlvbmVuIVwiXG4gICAgPlxuICAgICAgPGltZ1xuICAgICAgICBzcmM9e2ltZ1NyY31cbiAgICAgICAgYWx0PXtgQ2hhcmFjdGVyICR7Y3VycmVudEVtb3Rpb259YH1cbiAgICAgICAgd2lkdGg9ezEyMH1cbiAgICAgICAgaGVpZ2h0PXsxNTB9XG4gICAgICAgIGNsYXNzTmFtZT17Z2V0QW5pbWF0aW9uQ2xhc3NlcygpfVxuICAgICAgICBzdHlsZT17eyBvYmplY3RGaXQ6ICdjb250YWluJywgcG9zaXRpb246ICdyZWxhdGl2ZScsIHpJbmRleDogMSwgb3BhY2l0eTogaW1nTG9hZGVkID8gMSA6IDAsIHRyYW5zaXRpb246ICdvcGFjaXR5IDAuMnMnIH19XG4gICAgICAgIG9uTG9hZD17KCkgPT4gc2V0SW1nTG9hZGVkKHRydWUpfVxuICAgICAgICBvbkVycm9yPXsoKSA9PiBzZXRJbWdMb2FkZWQodHJ1ZSl9XG4gICAgICAvPlxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQ2hhcmFjdGVyOyBcbi8vIENhY2hlLVJlZnJlc2g6IFVwZGF0ZWQgQ2hhcmFjdGVyIEFuaW1hdGlvbiBhbmQgcmVtb3ZlZCBpc0JvdW5jaW5nICJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZVJlZiIsIkltYWdlIiwiZ2V0Q2FjaGVkQXNzZXQiLCJnZXRDYWNoZWRBc3NldEFzQmxvYiIsImNoYXJhY3RlckluaXRpYWxpemVkIiwiQ2hhcmFjdGVyIiwiY3VycmVudENvbnRleHQiLCJvbkVtb3Rpb25DaGFuZ2UiLCJjdXJyZW50RW1vdGlvbiIsInNldEN1cnJlbnRFbW90aW9uIiwiaXNSb3RhdGluZyIsInNldElzUm90YXRpbmciLCJyb3RhdGlvblBoYXNlIiwic2V0Um90YXRpb25QaGFzZSIsImF2YWlsYWJsZUVtb3Rpb25zIiwic2V0QXZhaWxhYmxlRW1vdGlvbnMiLCJoYXNMb2FkZWQiLCJzZXRIYXNMb2FkZWQiLCJsYXN0UHJvY2Vzc2VkQ29udGV4dCIsInNldExhc3RQcm9jZXNzZWRDb250ZXh0IiwibGFzdEVtb3Rpb25DaGFuZ2VUaW1lIiwic2V0TGFzdEVtb3Rpb25DaGFuZ2VUaW1lIiwiYXV0b1Jlc2V0VGltZXIiLCJlbW90aW9uQ2hhbmdlVGltZXIiLCJjaGFyYWN0ZXJWYXJpYW50cyIsImlkbGUiLCJleGNpdGVkIiwiY3VyaW91cyIsInN1cnByaXNlZCIsInRoaW5raW5nIiwibGF1Z2hpbmciLCJleHBsb3JpbmciLCJzY2FyZWQiLCJzZWxlY3RlZFZhcmlhbnQiLCJzZXRTZWxlY3RlZFZhcmlhbnQiLCJpbWdMb2FkZWQiLCJzZXRJbWdMb2FkZWQiLCJpbWdTcmMiLCJzZXRJbWdTcmMiLCJvYmplY3RVcmwiLCJpc01vdW50ZWQiLCJ0aGVuIiwiYmxvYiIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsImNhdGNoIiwicmV2b2tlT2JqZWN0VVJMIiwic2VsZWN0VmFyaWFudEZvckVtb3Rpb24iLCJlbW90aW9uIiwidmFyaWFudHMiLCJsZW5ndGgiLCJ2YXJpYW50Iiwib3RoZXJWYXJpYW50cyIsImZpbHRlciIsInJhbmRvbVZhcmlhbnQiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJnZXRSYW5kb21FbW90aW9uIiwiZW1vdGlvbnMiLCJmaWx0ZXJlZCIsImUiLCJjaGFuZ2VFbW90aW9uIiwibmV3RW1vdGlvbiIsImltbWVkaWF0ZSIsImNvbnNvbGUiLCJsb2ciLCJzZXRUaW1lb3V0IiwibG9hZENvbnRleHRFbW90aW9ucyIsImNvbnRleHQiLCJjb250ZXh0RW1vdGlvbk1hcCIsIm1haW4iLCJjYXRlZ29yeSIsImFuaW1hbHMiLCJkZWZhdWx0Iiwibm93IiwiRGF0ZSIsInRpbWVTaW5jZUxhc3RDaGFuZ2UiLCJFTU9USU9OX0NPT0xET1dOIiwicmFuZG9tRW1vdGlvbiIsImVycm9yIiwicGxheVJhbmRvbUxhdWdodGVyIiwibGF1Z2h0ZXJGaWxlcyIsInJhbmRvbUxhdWdodGVyIiwibGF1Z2h0ZXJBdWRpbyIsIkF1ZGlvIiwidm9sdW1lIiwicGxheSIsImVyciIsImhhbmRsZUNoYXJhY3RlckNsaWNrIiwiaGFwcHlFbW90aW9ucyIsInJhbmRvbUhhcHB5RW1vdGlvbiIsImxvYWRUaW1lciIsImNsZWFyVGltZW91dCIsImxhc3RDb250ZXh0UmVmIiwiY3VycmVudCIsImRpZENhbmNlbCIsImZhbGxiYWNrVGltZXIiLCJnZXRBbmltYXRpb25DbGFzc2VzIiwiY2xhc3NlcyIsImRpdiIsImNsYXNzTmFtZSIsIm9uQ2xpY2siLCJ0aXRsZSIsImltZyIsInNyYyIsImFsdCIsIndpZHRoIiwiaGVpZ2h0Iiwic3R5bGUiLCJvYmplY3RGaXQiLCJwb3NpdGlvbiIsInpJbmRleCIsIm9wYWNpdHkiLCJ0cmFuc2l0aW9uIiwib25Mb2FkIiwib25FcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./components/Character.js\n"));

/***/ })

});