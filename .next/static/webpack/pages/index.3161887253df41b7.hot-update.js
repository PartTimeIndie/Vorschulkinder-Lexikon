"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./components/Character.js":
/*!*********************************!*\
  !*** ./components/Character.js ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/image */ \"./node_modules/next/image.js\");\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_image__WEBPACK_IMPORTED_MODULE_2__);\n\nvar _s = $RefreshSig$();\n\n\n// Statische Variable um sicherzustellen dass Character nur EINMAL initialisiert wird\nlet characterInitialized = false;\nconst Character = (param)=>{\n    let { currentContext = \"idle\", onEmotionChange } = param;\n    _s();\n    const [currentEmotion, setCurrentEmotion] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"idle\");\n    const [isRotating, setIsRotating] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [rotationPhase, setRotationPhase] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"idle\"); // 'idle', 'out', 'in'\n    const [availableEmotions, setAvailableEmotions] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([\n        \"idle\",\n        \"curious\"\n    ]);\n    const [hasLoaded, setHasLoaded] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(characterInitialized); // Für initiale Fly-In Animation - einmal für immer\n    const [lastProcessedContext, setLastProcessedContext] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null); // Verhindert mehrfache Emotion-Wechsel\n    const [lastEmotionChangeTime, setLastEmotionChangeTime] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0); // Cooldown für Emotion-Changes\n    const autoResetTimer = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const emotionChangeTimer = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Character-Bilder-Varianten definieren\n    const characterVariants = {\n        idle: [\n            \"/Characters/Character-idle.png\",\n            \"/Characters/Character-idle-2.png\",\n            \"/Characters/Character-idle-3.png\"\n        ],\n        excited: [\n            \"/Characters/Character-excited.png\",\n            \"/Characters/Character-excited-2.png\",\n            \"/Characters/Character-excited-3.png\"\n        ],\n        curious: [\n            \"/Characters/Character-curious.png\",\n            \"/Characters/Character-curious-2.png\",\n            \"/Characters/Character-curious-3.png\"\n        ],\n        surprised: [\n            \"/Characters/Character-surprised.png\",\n            \"/Characters/Character-surprised-2.png\",\n            \"/Characters/Character-surprised-3.png\"\n        ],\n        thinking: [\n            \"/Characters/Character-thinking.png\",\n            \"/Characters/Character-thinking-2.png\",\n            \"/Characters/Character-thinking-3.png\"\n        ],\n        laughing: [\n            \"/Characters/Character-laughing.png\",\n            \"/Characters/Character-laughing-2.png\"\n        ],\n        exploring: [\n            \"/Characters/Character-excited.png\",\n            \"/Characters/Character-excited-2.png\",\n            \"/Characters/Character-excited-3.png\"\n        ],\n        scared: [\n            \"/Characters/Character-surprised.png\",\n            \"/Characters/Character-surprised-2.png\",\n            \"/Characters/Character-surprised-3.png\"\n        ]\n    };\n    // State für gewählte Variante pro Emotion\n    const [selectedVariant, setSelectedVariant] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"/Characters/Character-idle.png\");\n    // Zufällige Variante für Emotion wählen und speichern (NIEMALS die gleiche)\n    const selectVariantForEmotion = (emotion)=>{\n        const variants = characterVariants[emotion] || characterVariants.idle;\n        // Wenn nur eine Variante vorhanden, diese nehmen\n        if (variants.length === 1) {\n            const variant = variants[0];\n            setSelectedVariant(variant);\n            return variant;\n        }\n        // Aktuelle Variante rausfiltern um Wiederholung zu vermeiden\n        const otherVariants = variants.filter((variant)=>variant !== selectedVariant);\n        // Falls alle Varianten die gleiche sind (sollte nicht passieren), erste nehmen\n        if (otherVariants.length === 0) {\n            const variant = variants[0];\n            setSelectedVariant(variant);\n            return variant;\n        }\n        // Zufällige andere Variante wählen\n        const randomVariant = otherVariants[Math.floor(Math.random() * otherVariants.length)];\n        setSelectedVariant(randomVariant);\n        return randomVariant;\n    };\n    // Zufällige Emotion aus verfügbaren Emotionen wählen\n    const getRandomEmotion = function() {\n        let emotions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : availableEmotions;\n        const filtered = emotions.filter((e)=>e !== currentEmotion);\n        if (filtered.length === 0) return emotions[0];\n        return filtered[Math.floor(Math.random() * filtered.length)];\n    };\n    // Emotion-Wechsel mit ursprünglicher Flip-Animation\n    const changeEmotion = function(newEmotion) {\n        let immediate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        console.log(\"\\uD83C\\uDFAD Emotion change: \".concat(currentEmotion, \" → \").concat(newEmotion));\n        if (newEmotion === currentEmotion) {\n            return;\n        }\n        if (immediate) {\n            // Direkter Wechsel ohne Animation\n            setCurrentEmotion(newEmotion);\n            selectVariantForEmotion(newEmotion);\n            return;\n        }\n        // Flip-Animation: Raus -> Bild wechseln -> Rein\n        setIsRotating(true);\n        setRotationPhase(\"out\");\n        // Nach Raus-Animation: Bild wechseln\n        setTimeout(()=>{\n            setCurrentEmotion(newEmotion);\n            selectVariantForEmotion(newEmotion);\n            setRotationPhase(\"in\");\n            // Nach Rein-Animation: Animation beenden\n            setTimeout(()=>{\n                setRotationPhase(\"idle\");\n                setIsRotating(false);\n            }, 300);\n        }, 300);\n    };\n    // Auto-Reset entfernt - Character wechselt nur bei Interaktionen\n    // Context-abhängige Emotionen laden\n    const loadContextEmotions = async (context)=>{\n        console.log(\"\\uD83C\\uDFAD loadContextEmotions called with context: '\".concat(context, \"' (lastProcessed: '\").concat(lastProcessedContext, \"')\"));\n        try {\n            const response = await fetch(\"/api/character/random-emotion/\".concat(context));\n            const data = await response.json();\n            if (data.emotions) {\n                setAvailableEmotions(data.emotions);\n                // Cooldown prüfen: Keine Emotion-Wechsel wenn der letzte vor weniger als 2 Sekunden war\n                const now = Date.now();\n                const timeSinceLastChange = now - lastEmotionChangeTime;\n                const EMOTION_COOLDOWN = 2000; // 2 Sekunden Cooldown\n                console.log(\"\\uD83C\\uDFAD Context check: context=\".concat(context, \", lastProcessed=\").concat(lastProcessedContext, \", cooldown=\").concat(timeSinceLastChange, \"ms\"));\n                if (context !== \"idle\" && context !== lastProcessedContext && timeSinceLastChange >= EMOTION_COOLDOWN) {\n                    console.log(\"\\uD83C\\uDFAD TRIGGERING emotion change for context '\".concat(context, \"'\"));\n                    const randomEmotion = data.emotions[Math.floor(Math.random() * data.emotions.length)];\n                    changeEmotion(randomEmotion, false); // Mit Flip-Animation\n                    setLastProcessedContext(context); // Merke dass wir diesen Context schon verarbeitet haben\n                    setLastEmotionChangeTime(now); // Setze Cooldown-Timer\n                } else if (context === lastProcessedContext) {\n                    console.log(\"\\uD83C\\uDFAD BLOCKED: Context '\".concat(context, \"' already processed\"));\n                } else if (timeSinceLastChange < EMOTION_COOLDOWN) {\n                    console.log(\"\\uD83C\\uDFAD BLOCKED: Cooldown active (\".concat(timeSinceLastChange, \"ms < \").concat(EMOTION_COOLDOWN, \"ms)\"));\n                } else if (context === \"idle\") {\n                    // Bei idle-Context: Reset lastProcessedContext für nächste Interaktion (aber kein Cooldown Reset)\n                    console.log(\"\\uD83C\\uDFAD RESET: Idle context, clearing lastProcessedContext\");\n                    setLastProcessedContext(null);\n                // Character wird NICHT neu instanziert, nur hasLoaded bleibt true\n                }\n            }\n        } catch (error) {\n            console.error(\"Error loading context emotions:\", error);\n            setAvailableEmotions([\n                \"idle\",\n                \"curious\"\n            ]);\n        }\n    };\n    // Zufälliges Lachen abspielen (ohne Voice-Overs zu unterbrechen)\n    const playRandomLaughter = ()=>{\n        const laughterFiles = [\n            \"/audio/LaughingKid/laughing-1.wav\",\n            \"/audio/LaughingKid/laughing-2.wav\",\n            \"/audio/LaughingKid/laughing-3.wav\",\n            \"/audio/LaughingKid/laughing-4.wav\",\n            \"/audio/LaughingKid/laughing-5.wav\",\n            \"/audio/LaughingKid/laughing-6.wav\",\n            \"/audio/LaughingKid/laughing-7.wav\"\n        ];\n        // Zufällige Lacher-Datei auswählen\n        const randomLaughter = laughterFiles[Math.floor(Math.random() * laughterFiles.length)];\n        try {\n            // SEPARATES Audio-Element für Lacher (nicht global!)\n            const laughterAudio = new Audio(randomLaughter);\n            laughterAudio.volume = 0.7; // Etwas leiser als Voice-Overs\n            laughterAudio.play().catch((err)=>{\n                console.log(\"Lacher-Audio autoplay verhindert:\", err);\n            });\n            console.log(\"\\uD83E\\uDD23 Lacher abgespielt:\", randomLaughter);\n        } catch (error) {\n            console.error(\"Lacher-Audio-Fehler:\", error);\n        }\n    };\n    // Character antippen - Rotation, Emotion-Wechsel UND Lachen\n    const handleCharacterClick = ()=>{\n        // Zu laughing oder excited wechseln, aber NIEMALS die aktuelle Emotion\n        const happyEmotions = [\n            \"laughing\",\n            \"excited\"\n        ];\n        let randomHappyEmotion;\n        // Andere Emotion wählen als die aktuelle\n        if (currentEmotion === \"laughing\") {\n            randomHappyEmotion = \"excited\";\n        } else if (currentEmotion === \"excited\") {\n            randomHappyEmotion = \"laughing\";\n        } else {\n            // Wenn weder laughing noch excited, zufällig wählen\n            randomHappyEmotion = happyEmotions[Math.floor(Math.random() * happyEmotions.length)];\n        }\n        changeEmotion(randomHappyEmotion);\n        setLastEmotionChangeTime(Date.now()); // Cooldown-Timer auch bei direktem Character-Klick setzen\n        // Zufälliges Lachen abspielen (parallel zu Voice-Overs)\n        playRandomLaughter();\n        // Callback für Emotion-Änderung\n        if (onEmotionChange) {\n            onEmotionChange(randomHappyEmotion);\n        }\n    };\n    // Initial Fly-In Animation starten - NUR EINMAL in der gesamten App-Laufzeit\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!characterInitialized) {\n            console.log(\"\\uD83C\\uDFAD Character FIRST TIME INITIALIZATION\");\n            characterInitialized = true; // Setze statische Variable\n            // Nach kurzer Verzögerung Character reinfliegen lassen\n            const loadTimer = setTimeout(()=>{\n                setHasLoaded(true);\n            }, 300);\n            return ()=>clearTimeout(loadTimer);\n        } else {\n            console.log(\"\\uD83C\\uDFAD Character ALREADY INITIALIZED - skipping fly-in\");\n        }\n    }, []);\n    // Context-Änderungen überwachen - mit Ref um doppelte Aufrufe zu verhindern\n    const lastContextRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (currentContext && currentContext !== lastContextRef.current) {\n            console.log(\"\\uD83C\\uDFAD Processing NEW context: '\".concat(currentContext, \"'\"));\n            lastContextRef.current = currentContext;\n            loadContextEmotions(currentContext);\n        }\n    }, [\n        currentContext\n    ]);\n    // Cleanup Timer\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        return ()=>{\n            if (autoResetTimer.current) clearTimeout(autoResetTimer.current);\n            if (emotionChangeTimer.current) clearTimeout(emotionChangeTimer.current);\n        };\n    }, []);\n    // Animation-Klassen bestimmen\n    const getAnimationClasses = ()=>{\n        let classes = \"character-image\";\n        // Initial Fly-In Animation beim ersten Laden\n        if (!hasLoaded) {\n            classes += \" character-fly-in\";\n            return classes;\n        }\n        if (rotationPhase === \"out\") {\n            classes += \" character-rotate-out\";\n        } else if (rotationPhase === \"in\") {\n            classes += \" character-rotate-in\";\n        }\n        // Subtile Loop-Animation wenn keine Rotation läuft\n        if (rotationPhase === \"idle\") {\n            classes += \" character-subtle-animation\";\n        }\n        return classes;\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"character-container\",\n        onClick: handleCharacterClick,\n        title: \"Character antippen f\\xfcr Emotionen!\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_image__WEBPACK_IMPORTED_MODULE_2___default()), {\n            src: selectedVariant,\n            alt: \"Character \".concat(currentEmotion),\n            width: 120,\n            height: 150,\n            className: getAnimationClasses(),\n            priority: true,\n            unoptimized: true\n        }, void 0, false, {\n            fileName: \"D:\\\\gitrepros\\\\Vorschulkinder Lexikon\\\\components\\\\Character.js\",\n            lineNumber: 300,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"D:\\\\gitrepros\\\\Vorschulkinder Lexikon\\\\components\\\\Character.js\",\n        lineNumber: 295,\n        columnNumber: 5\n    }, undefined);\n};\n_s(Character, \"7RY+bcYwtpsnjABeJzl27sr45rk=\");\n_c = Character;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Character); // Cache-Refresh: Updated Character Animation and removed isBouncing \nvar _c;\n$RefreshReg$(_c, \"Character\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL0NoYXJhY3Rlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBb0Q7QUFDckI7QUFFL0IscUZBQXFGO0FBQ3JGLElBQUlJLHVCQUF1QjtBQUUzQixNQUFNQyxZQUFZO1FBQUMsRUFBRUMsaUJBQWlCLE1BQU0sRUFBRUMsZUFBZSxFQUFFOztJQUM3RCxNQUFNLENBQUNDLGdCQUFnQkMsa0JBQWtCLEdBQUdULCtDQUFRQSxDQUFDO0lBQ3JELE1BQU0sQ0FBQ1UsWUFBWUMsY0FBYyxHQUFHWCwrQ0FBUUEsQ0FBQztJQUM3QyxNQUFNLENBQUNZLGVBQWVDLGlCQUFpQixHQUFHYiwrQ0FBUUEsQ0FBQyxTQUFTLHNCQUFzQjtJQUNsRixNQUFNLENBQUNjLG1CQUFtQkMscUJBQXFCLEdBQUdmLCtDQUFRQSxDQUFDO1FBQUM7UUFBUTtLQUFVO0lBQzlFLE1BQU0sQ0FBQ2dCLFdBQVdDLGFBQWEsR0FBR2pCLCtDQUFRQSxDQUFDSSx1QkFBdUIsbURBQW1EO0lBQ3JILE1BQU0sQ0FBQ2Msc0JBQXNCQyx3QkFBd0IsR0FBR25CLCtDQUFRQSxDQUFDLE9BQU8sdUNBQXVDO0lBQy9HLE1BQU0sQ0FBQ29CLHVCQUF1QkMseUJBQXlCLEdBQUdyQiwrQ0FBUUEsQ0FBQyxJQUFJLCtCQUErQjtJQUV0RyxNQUFNc0IsaUJBQWlCcEIsNkNBQU1BLENBQUM7SUFDOUIsTUFBTXFCLHFCQUFxQnJCLDZDQUFNQSxDQUFDO0lBRWxDLHdDQUF3QztJQUN4QyxNQUFNc0Isb0JBQW9CO1FBQ3hCQyxNQUFNO1lBQ0o7WUFDQTtZQUNBO1NBQ0Q7UUFDREMsU0FBUztZQUNQO1lBQ0E7WUFDQTtTQUNEO1FBQ0RDLFNBQVM7WUFDUDtZQUNBO1lBQ0E7U0FDRDtRQUNEQyxXQUFXO1lBQ1Q7WUFDQTtZQUNBO1NBQ0Q7UUFDREMsVUFBVTtZQUNSO1lBQ0E7WUFDQTtTQUNEO1FBQ0RDLFVBQVU7WUFDUjtZQUNBO1NBQ0Q7UUFDREMsV0FBVztZQUNUO1lBQ0E7WUFDQTtTQUNEO1FBQ0RDLFFBQVE7WUFDTjtZQUNBO1lBQ0E7U0FDRDtJQUNIO0lBRUEsMENBQTBDO0lBQzFDLE1BQU0sQ0FBQ0MsaUJBQWlCQyxtQkFBbUIsR0FBR2xDLCtDQUFRQSxDQUFDO0lBRXZELDRFQUE0RTtJQUM1RSxNQUFNbUMsMEJBQTBCLENBQUNDO1FBQy9CLE1BQU1DLFdBQVdiLGlCQUFpQixDQUFDWSxRQUFRLElBQUlaLGtCQUFrQkMsSUFBSTtRQUVyRSxpREFBaUQ7UUFDakQsSUFBSVksU0FBU0MsTUFBTSxLQUFLLEdBQUc7WUFDekIsTUFBTUMsVUFBVUYsUUFBUSxDQUFDLEVBQUU7WUFDM0JILG1CQUFtQks7WUFDbkIsT0FBT0E7UUFDVDtRQUVBLDZEQUE2RDtRQUM3RCxNQUFNQyxnQkFBZ0JILFNBQVNJLE1BQU0sQ0FBQ0YsQ0FBQUEsVUFBV0EsWUFBWU47UUFFN0QsK0VBQStFO1FBQy9FLElBQUlPLGNBQWNGLE1BQU0sS0FBSyxHQUFHO1lBQzlCLE1BQU1DLFVBQVVGLFFBQVEsQ0FBQyxFQUFFO1lBQzNCSCxtQkFBbUJLO1lBQ25CLE9BQU9BO1FBQ1Q7UUFFQSxtQ0FBbUM7UUFDbkMsTUFBTUcsZ0JBQWdCRixhQUFhLENBQUNHLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS0UsTUFBTSxLQUFLTCxjQUFjRixNQUFNLEVBQUU7UUFDckZKLG1CQUFtQlE7UUFDbkIsT0FBT0E7SUFDVDtJQUVBLHFEQUFxRDtJQUNyRCxNQUFNSSxtQkFBbUI7WUFBQ0MsNEVBQVdqQztRQUNuQyxNQUFNa0MsV0FBV0QsU0FBU04sTUFBTSxDQUFDUSxDQUFBQSxJQUFLQSxNQUFNekM7UUFDNUMsSUFBSXdDLFNBQVNWLE1BQU0sS0FBSyxHQUFHLE9BQU9TLFFBQVEsQ0FBQyxFQUFFO1FBQzdDLE9BQU9DLFFBQVEsQ0FBQ0wsS0FBS0MsS0FBSyxDQUFDRCxLQUFLRSxNQUFNLEtBQUtHLFNBQVNWLE1BQU0sRUFBRTtJQUM5RDtJQUVBLG9EQUFvRDtJQUNwRCxNQUFNWSxnQkFBZ0IsU0FBQ0M7WUFBWUMsNkVBQVk7UUFDN0NDLFFBQVFDLEdBQUcsQ0FBQyxnQ0FBMENILE9BQXBCM0MsZ0JBQWUsT0FBZ0IsT0FBWDJDO1FBRXRELElBQUlBLGVBQWUzQyxnQkFBZ0I7WUFDakM7UUFDRjtRQUVBLElBQUk0QyxXQUFXO1lBQ2Isa0NBQWtDO1lBQ2xDM0Msa0JBQWtCMEM7WUFDbEJoQix3QkFBd0JnQjtZQUN4QjtRQUNGO1FBRUEsZ0RBQWdEO1FBQ2hEeEMsY0FBYztRQUNkRSxpQkFBaUI7UUFFakIscUNBQXFDO1FBQ3JDMEMsV0FBVztZQUNUOUMsa0JBQWtCMEM7WUFDbEJoQix3QkFBd0JnQjtZQUN4QnRDLGlCQUFpQjtZQUVqQix5Q0FBeUM7WUFDekMwQyxXQUFXO2dCQUNUMUMsaUJBQWlCO2dCQUNqQkYsY0FBYztZQUNoQixHQUFHO1FBQ0wsR0FBRztJQUNMO0lBRUEsaUVBQWlFO0lBRWpFLG9DQUFvQztJQUNwQyxNQUFNNkMsc0JBQXNCLE9BQU9DO1FBQ2pDSixRQUFRQyxHQUFHLENBQUMsMERBQTZFcEMsT0FBN0J1QyxTQUFRLHVCQUEwQyxPQUFyQnZDLHNCQUFxQjtRQUU5RyxJQUFJO1lBQ0YsTUFBTXdDLFdBQVcsTUFBTUMsTUFBTSxpQ0FBeUMsT0FBUkY7WUFDOUQsTUFBTUcsT0FBTyxNQUFNRixTQUFTRyxJQUFJO1lBRWhDLElBQUlELEtBQUtiLFFBQVEsRUFBRTtnQkFDakJoQyxxQkFBcUI2QyxLQUFLYixRQUFRO2dCQUVsQyx3RkFBd0Y7Z0JBQ3hGLE1BQU1lLE1BQU1DLEtBQUtELEdBQUc7Z0JBQ3BCLE1BQU1FLHNCQUFzQkYsTUFBTTFDO2dCQUNsQyxNQUFNNkMsbUJBQW1CLE1BQU0sc0JBQXNCO2dCQUVyRFosUUFBUUMsR0FBRyxDQUFDLHVDQUF1RHBDLE9BQTFCdUMsU0FBUSxvQkFBb0RPLE9BQWxDOUMsc0JBQXFCLGVBQWlDLE9BQXBCOEMscUJBQW9CO2dCQUV6SCxJQUFJUCxZQUFZLFVBQVVBLFlBQVl2Qyx3QkFBd0I4Qyx1QkFBdUJDLGtCQUFrQjtvQkFDckdaLFFBQVFDLEdBQUcsQ0FBQyx1REFBcUQsT0FBUkcsU0FBUTtvQkFDakUsTUFBTVMsZ0JBQWdCTixLQUFLYixRQUFRLENBQUNKLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS0UsTUFBTSxLQUFLZSxLQUFLYixRQUFRLENBQUNULE1BQU0sRUFBRTtvQkFDckZZLGNBQWNnQixlQUFlLFFBQVEscUJBQXFCO29CQUMxRC9DLHdCQUF3QnNDLFVBQVUsd0RBQXdEO29CQUMxRnBDLHlCQUF5QnlDLE1BQU0sdUJBQXVCO2dCQUN4RCxPQUFPLElBQUlMLFlBQVl2QyxzQkFBc0I7b0JBQzNDbUMsUUFBUUMsR0FBRyxDQUFDLGtDQUFnQyxPQUFSRyxTQUFRO2dCQUM5QyxPQUFPLElBQUlPLHNCQUFzQkMsa0JBQWtCO29CQUNqRFosUUFBUUMsR0FBRyxDQUFDLDBDQUEyRFcsT0FBM0JELHFCQUFvQixTQUF3QixPQUFqQkMsa0JBQWlCO2dCQUMxRixPQUFPLElBQUlSLFlBQVksUUFBUTtvQkFDN0Isa0dBQWtHO29CQUNsR0osUUFBUUMsR0FBRyxDQUFFO29CQUNibkMsd0JBQXdCO2dCQUN4QixrRUFBa0U7Z0JBQ3BFO1lBQ0Y7UUFDRixFQUFFLE9BQU9nRCxPQUFPO1lBQ2RkLFFBQVFjLEtBQUssQ0FBQyxtQ0FBbUNBO1lBQ2pEcEQscUJBQXFCO2dCQUFDO2dCQUFRO2FBQVU7UUFDMUM7SUFDRjtJQUVBLGlFQUFpRTtJQUNqRSxNQUFNcUQscUJBQXFCO1FBQ3pCLE1BQU1DLGdCQUFnQjtZQUNwQjtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtTQUNEO1FBRUQsbUNBQW1DO1FBQ25DLE1BQU1DLGlCQUFpQkQsYUFBYSxDQUFDMUIsS0FBS0MsS0FBSyxDQUFDRCxLQUFLRSxNQUFNLEtBQUt3QixjQUFjL0IsTUFBTSxFQUFFO1FBRXRGLElBQUk7WUFDRixxREFBcUQ7WUFDckQsTUFBTWlDLGdCQUFnQixJQUFJQyxNQUFNRjtZQUNoQ0MsY0FBY0UsTUFBTSxHQUFHLEtBQUssK0JBQStCO1lBRTNERixjQUFjRyxJQUFJLEdBQUdDLEtBQUssQ0FBQ0MsQ0FBQUE7Z0JBQ3pCdkIsUUFBUUMsR0FBRyxDQUFDLHFDQUFxQ3NCO1lBQ25EO1lBRUF2QixRQUFRQyxHQUFHLENBQUMsbUNBQXlCZ0I7UUFFdkMsRUFBRSxPQUFPSCxPQUFPO1lBQ2RkLFFBQVFjLEtBQUssQ0FBQyx3QkFBd0JBO1FBQ3hDO0lBQ0Y7SUFFQSw0REFBNEQ7SUFDNUQsTUFBTVUsdUJBQXVCO1FBQzNCLHVFQUF1RTtRQUN2RSxNQUFNQyxnQkFBZ0I7WUFBQztZQUFZO1NBQVU7UUFDN0MsSUFBSUM7UUFFSix5Q0FBeUM7UUFDekMsSUFBSXZFLG1CQUFtQixZQUFZO1lBQ2pDdUUscUJBQXFCO1FBQ3ZCLE9BQU8sSUFBSXZFLG1CQUFtQixXQUFXO1lBQ3ZDdUUscUJBQXFCO1FBQ3ZCLE9BQU87WUFDTCxvREFBb0Q7WUFDcERBLHFCQUFxQkQsYUFBYSxDQUFDbkMsS0FBS0MsS0FBSyxDQUFDRCxLQUFLRSxNQUFNLEtBQUtpQyxjQUFjeEMsTUFBTSxFQUFFO1FBQ3RGO1FBRUFZLGNBQWM2QjtRQUNkMUQseUJBQXlCMEMsS0FBS0QsR0FBRyxLQUFLLDBEQUEwRDtRQUVoRyx3REFBd0Q7UUFDeERNO1FBRUEsZ0NBQWdDO1FBQ2hDLElBQUk3RCxpQkFBaUI7WUFDbkJBLGdCQUFnQndFO1FBQ2xCO0lBQ0Y7SUFFQSw2RUFBNkU7SUFDN0U5RSxnREFBU0EsQ0FBQztRQUNSLElBQUksQ0FBQ0csc0JBQXNCO1lBQ3pCaUQsUUFBUUMsR0FBRyxDQUFFO1lBQ2JsRCx1QkFBdUIsTUFBTSwyQkFBMkI7WUFFeEQsdURBQXVEO1lBQ3ZELE1BQU00RSxZQUFZekIsV0FBVztnQkFDM0J0QyxhQUFhO1lBQ2YsR0FBRztZQUVILE9BQU8sSUFBTWdFLGFBQWFEO1FBQzVCLE9BQU87WUFDTDNCLFFBQVFDLEdBQUcsQ0FBRTtRQUNmO0lBQ0YsR0FBRyxFQUFFO0lBRUwsNEVBQTRFO0lBQzVFLE1BQU00QixpQkFBaUJoRiw2Q0FBTUEsQ0FBQztJQUU5QkQsZ0RBQVNBLENBQUM7UUFDUixJQUFJSyxrQkFBa0JBLG1CQUFtQjRFLGVBQWVDLE9BQU8sRUFBRTtZQUMvRDlCLFFBQVFDLEdBQUcsQ0FBQyx5Q0FBOEMsT0FBZmhELGdCQUFlO1lBQzFENEUsZUFBZUMsT0FBTyxHQUFHN0U7WUFDekJrRCxvQkFBb0JsRDtRQUN0QjtJQUNGLEdBQUc7UUFBQ0E7S0FBZTtJQUVuQixnQkFBZ0I7SUFDaEJMLGdEQUFTQSxDQUFDO1FBQ1IsT0FBTztZQUNMLElBQUlxQixlQUFlNkQsT0FBTyxFQUFFRixhQUFhM0QsZUFBZTZELE9BQU87WUFDL0QsSUFBSTVELG1CQUFtQjRELE9BQU8sRUFBRUYsYUFBYTFELG1CQUFtQjRELE9BQU87UUFDekU7SUFDRixHQUFHLEVBQUU7SUFFTCw4QkFBOEI7SUFDOUIsTUFBTUMsc0JBQXNCO1FBQzFCLElBQUlDLFVBQVU7UUFFZCw2Q0FBNkM7UUFDN0MsSUFBSSxDQUFDckUsV0FBVztZQUNkcUUsV0FBVztZQUNYLE9BQU9BO1FBQ1Q7UUFFQSxJQUFJekUsa0JBQWtCLE9BQU87WUFDM0J5RSxXQUFXO1FBQ2IsT0FBTyxJQUFJekUsa0JBQWtCLE1BQU07WUFDakN5RSxXQUFXO1FBQ2I7UUFFQSxtREFBbUQ7UUFDbkQsSUFBSXpFLGtCQUFrQixRQUFRO1lBQzVCeUUsV0FBVztRQUNiO1FBRUEsT0FBT0E7SUFDVDtJQUVBLHFCQUNFLDhEQUFDQztRQUNDQyxXQUFVO1FBQ1ZDLFNBQVNYO1FBQ1RZLE9BQU07a0JBRU4sNEVBQUN0RixtREFBS0E7WUFDSnVGLEtBQUt6RDtZQUNMMEQsS0FBSyxhQUE0QixPQUFmbkY7WUFDbEJvRixPQUFPO1lBQ1BDLFFBQVE7WUFDUk4sV0FBV0g7WUFDWFUsUUFBUTtZQUNSQyxXQUFXOzs7Ozs7Ozs7OztBQUluQjtHQWhUTTFGO0tBQUFBO0FBa1ROLCtEQUFlQSxTQUFTQSxFQUFDLENBQ3pCLHFFQUFxRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0NoYXJhY3Rlci5qcz9lMjdmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBJbWFnZSBmcm9tICduZXh0L2ltYWdlJztcblxuLy8gU3RhdGlzY2hlIFZhcmlhYmxlIHVtIHNpY2hlcnp1c3RlbGxlbiBkYXNzIENoYXJhY3RlciBudXIgRUlOTUFMIGluaXRpYWxpc2llcnQgd2lyZFxubGV0IGNoYXJhY3RlckluaXRpYWxpemVkID0gZmFsc2U7XG5cbmNvbnN0IENoYXJhY3RlciA9ICh7IGN1cnJlbnRDb250ZXh0ID0gJ2lkbGUnLCBvbkVtb3Rpb25DaGFuZ2UgfSkgPT4ge1xuICBjb25zdCBbY3VycmVudEVtb3Rpb24sIHNldEN1cnJlbnRFbW90aW9uXSA9IHVzZVN0YXRlKCdpZGxlJyk7XG4gIGNvbnN0IFtpc1JvdGF0aW5nLCBzZXRJc1JvdGF0aW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3JvdGF0aW9uUGhhc2UsIHNldFJvdGF0aW9uUGhhc2VdID0gdXNlU3RhdGUoJ2lkbGUnKTsgLy8gJ2lkbGUnLCAnb3V0JywgJ2luJ1xuICBjb25zdCBbYXZhaWxhYmxlRW1vdGlvbnMsIHNldEF2YWlsYWJsZUVtb3Rpb25zXSA9IHVzZVN0YXRlKFsnaWRsZScsICdjdXJpb3VzJ10pO1xuICBjb25zdCBbaGFzTG9hZGVkLCBzZXRIYXNMb2FkZWRdID0gdXNlU3RhdGUoY2hhcmFjdGVySW5pdGlhbGl6ZWQpOyAvLyBGw7xyIGluaXRpYWxlIEZseS1JbiBBbmltYXRpb24gLSBlaW5tYWwgZsO8ciBpbW1lclxuICBjb25zdCBbbGFzdFByb2Nlc3NlZENvbnRleHQsIHNldExhc3RQcm9jZXNzZWRDb250ZXh0XSA9IHVzZVN0YXRlKG51bGwpOyAvLyBWZXJoaW5kZXJ0IG1laHJmYWNoZSBFbW90aW9uLVdlY2hzZWxcbiAgY29uc3QgW2xhc3RFbW90aW9uQ2hhbmdlVGltZSwgc2V0TGFzdEVtb3Rpb25DaGFuZ2VUaW1lXSA9IHVzZVN0YXRlKDApOyAvLyBDb29sZG93biBmw7xyIEVtb3Rpb24tQ2hhbmdlc1xuICBcbiAgY29uc3QgYXV0b1Jlc2V0VGltZXIgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IGVtb3Rpb25DaGFuZ2VUaW1lciA9IHVzZVJlZihudWxsKTtcblxuICAvLyBDaGFyYWN0ZXItQmlsZGVyLVZhcmlhbnRlbiBkZWZpbmllcmVuXG4gIGNvbnN0IGNoYXJhY3RlclZhcmlhbnRzID0ge1xuICAgIGlkbGU6IFtcbiAgICAgICcvQ2hhcmFjdGVycy9DaGFyYWN0ZXItaWRsZS5wbmcnLFxuICAgICAgJy9DaGFyYWN0ZXJzL0NoYXJhY3Rlci1pZGxlLTIucG5nJyxcbiAgICAgICcvQ2hhcmFjdGVycy9DaGFyYWN0ZXItaWRsZS0zLnBuZydcbiAgICBdLFxuICAgIGV4Y2l0ZWQ6IFtcbiAgICAgICcvQ2hhcmFjdGVycy9DaGFyYWN0ZXItZXhjaXRlZC5wbmcnLFxuICAgICAgJy9DaGFyYWN0ZXJzL0NoYXJhY3Rlci1leGNpdGVkLTIucG5nJyxcbiAgICAgICcvQ2hhcmFjdGVycy9DaGFyYWN0ZXItZXhjaXRlZC0zLnBuZydcbiAgICBdLFxuICAgIGN1cmlvdXM6IFtcbiAgICAgICcvQ2hhcmFjdGVycy9DaGFyYWN0ZXItY3VyaW91cy5wbmcnLFxuICAgICAgJy9DaGFyYWN0ZXJzL0NoYXJhY3Rlci1jdXJpb3VzLTIucG5nJyxcbiAgICAgICcvQ2hhcmFjdGVycy9DaGFyYWN0ZXItY3VyaW91cy0zLnBuZydcbiAgICBdLFxuICAgIHN1cnByaXNlZDogW1xuICAgICAgJy9DaGFyYWN0ZXJzL0NoYXJhY3Rlci1zdXJwcmlzZWQucG5nJyxcbiAgICAgICcvQ2hhcmFjdGVycy9DaGFyYWN0ZXItc3VycHJpc2VkLTIucG5nJyxcbiAgICAgICcvQ2hhcmFjdGVycy9DaGFyYWN0ZXItc3VycHJpc2VkLTMucG5nJ1xuICAgIF0sXG4gICAgdGhpbmtpbmc6IFtcbiAgICAgICcvQ2hhcmFjdGVycy9DaGFyYWN0ZXItdGhpbmtpbmcucG5nJyxcbiAgICAgICcvQ2hhcmFjdGVycy9DaGFyYWN0ZXItdGhpbmtpbmctMi5wbmcnLFxuICAgICAgJy9DaGFyYWN0ZXJzL0NoYXJhY3Rlci10aGlua2luZy0zLnBuZydcbiAgICBdLFxuICAgIGxhdWdoaW5nOiBbXG4gICAgICAnL0NoYXJhY3RlcnMvQ2hhcmFjdGVyLWxhdWdoaW5nLnBuZycsXG4gICAgICAnL0NoYXJhY3RlcnMvQ2hhcmFjdGVyLWxhdWdoaW5nLTIucG5nJ1xuICAgIF0sXG4gICAgZXhwbG9yaW5nOiBbXG4gICAgICAnL0NoYXJhY3RlcnMvQ2hhcmFjdGVyLWV4Y2l0ZWQucG5nJyxcbiAgICAgICcvQ2hhcmFjdGVycy9DaGFyYWN0ZXItZXhjaXRlZC0yLnBuZycsXG4gICAgICAnL0NoYXJhY3RlcnMvQ2hhcmFjdGVyLWV4Y2l0ZWQtMy5wbmcnXG4gICAgXSxcbiAgICBzY2FyZWQ6IFtcbiAgICAgICcvQ2hhcmFjdGVycy9DaGFyYWN0ZXItc3VycHJpc2VkLnBuZycsXG4gICAgICAnL0NoYXJhY3RlcnMvQ2hhcmFjdGVyLXN1cnByaXNlZC0yLnBuZycsXG4gICAgICAnL0NoYXJhY3RlcnMvQ2hhcmFjdGVyLXN1cnByaXNlZC0zLnBuZydcbiAgICBdLFxuICB9O1xuXG4gIC8vIFN0YXRlIGbDvHIgZ2V3w6RobHRlIFZhcmlhbnRlIHBybyBFbW90aW9uXG4gIGNvbnN0IFtzZWxlY3RlZFZhcmlhbnQsIHNldFNlbGVjdGVkVmFyaWFudF0gPSB1c2VTdGF0ZSgnL0NoYXJhY3RlcnMvQ2hhcmFjdGVyLWlkbGUucG5nJyk7XG5cbiAgLy8gWnVmw6RsbGlnZSBWYXJpYW50ZSBmw7xyIEVtb3Rpb24gd8OkaGxlbiB1bmQgc3BlaWNoZXJuIChOSUVNQUxTIGRpZSBnbGVpY2hlKVxuICBjb25zdCBzZWxlY3RWYXJpYW50Rm9yRW1vdGlvbiA9IChlbW90aW9uKSA9PiB7XG4gICAgY29uc3QgdmFyaWFudHMgPSBjaGFyYWN0ZXJWYXJpYW50c1tlbW90aW9uXSB8fCBjaGFyYWN0ZXJWYXJpYW50cy5pZGxlO1xuICAgIFxuICAgIC8vIFdlbm4gbnVyIGVpbmUgVmFyaWFudGUgdm9yaGFuZGVuLCBkaWVzZSBuZWhtZW5cbiAgICBpZiAodmFyaWFudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCB2YXJpYW50ID0gdmFyaWFudHNbMF07XG4gICAgICBzZXRTZWxlY3RlZFZhcmlhbnQodmFyaWFudCk7XG4gICAgICByZXR1cm4gdmFyaWFudDtcbiAgICB9XG4gICAgXG4gICAgLy8gQWt0dWVsbGUgVmFyaWFudGUgcmF1c2ZpbHRlcm4gdW0gV2llZGVyaG9sdW5nIHp1IHZlcm1laWRlblxuICAgIGNvbnN0IG90aGVyVmFyaWFudHMgPSB2YXJpYW50cy5maWx0ZXIodmFyaWFudCA9PiB2YXJpYW50ICE9PSBzZWxlY3RlZFZhcmlhbnQpO1xuICAgIFxuICAgIC8vIEZhbGxzIGFsbGUgVmFyaWFudGVuIGRpZSBnbGVpY2hlIHNpbmQgKHNvbGx0ZSBuaWNodCBwYXNzaWVyZW4pLCBlcnN0ZSBuZWhtZW5cbiAgICBpZiAob3RoZXJWYXJpYW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnN0IHZhcmlhbnQgPSB2YXJpYW50c1swXTtcbiAgICAgIHNldFNlbGVjdGVkVmFyaWFudCh2YXJpYW50KTtcbiAgICAgIHJldHVybiB2YXJpYW50O1xuICAgIH1cbiAgICBcbiAgICAvLyBadWbDpGxsaWdlIGFuZGVyZSBWYXJpYW50ZSB3w6RobGVuXG4gICAgY29uc3QgcmFuZG9tVmFyaWFudCA9IG90aGVyVmFyaWFudHNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogb3RoZXJWYXJpYW50cy5sZW5ndGgpXTtcbiAgICBzZXRTZWxlY3RlZFZhcmlhbnQocmFuZG9tVmFyaWFudCk7XG4gICAgcmV0dXJuIHJhbmRvbVZhcmlhbnQ7XG4gIH07XG5cbiAgLy8gWnVmw6RsbGlnZSBFbW90aW9uIGF1cyB2ZXJmw7xnYmFyZW4gRW1vdGlvbmVuIHfDpGhsZW5cbiAgY29uc3QgZ2V0UmFuZG9tRW1vdGlvbiA9IChlbW90aW9ucyA9IGF2YWlsYWJsZUVtb3Rpb25zKSA9PiB7XG4gICAgY29uc3QgZmlsdGVyZWQgPSBlbW90aW9ucy5maWx0ZXIoZSA9PiBlICE9PSBjdXJyZW50RW1vdGlvbik7XG4gICAgaWYgKGZpbHRlcmVkLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGVtb3Rpb25zWzBdO1xuICAgIHJldHVybiBmaWx0ZXJlZFtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBmaWx0ZXJlZC5sZW5ndGgpXTtcbiAgfTtcblxuICAvLyBFbW90aW9uLVdlY2hzZWwgbWl0IHVyc3Byw7xuZ2xpY2hlciBGbGlwLUFuaW1hdGlvblxuICBjb25zdCBjaGFuZ2VFbW90aW9uID0gKG5ld0Vtb3Rpb24sIGltbWVkaWF0ZSA9IGZhbHNlKSA9PiB7XG4gICAgY29uc29sZS5sb2coYPCfjq0gRW1vdGlvbiBjaGFuZ2U6ICR7Y3VycmVudEVtb3Rpb259IOKGkiAke25ld0Vtb3Rpb259YCk7XG4gICAgXG4gICAgaWYgKG5ld0Vtb3Rpb24gPT09IGN1cnJlbnRFbW90aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGlmIChpbW1lZGlhdGUpIHtcbiAgICAgIC8vIERpcmVrdGVyIFdlY2hzZWwgb2huZSBBbmltYXRpb25cbiAgICAgIHNldEN1cnJlbnRFbW90aW9uKG5ld0Vtb3Rpb24pO1xuICAgICAgc2VsZWN0VmFyaWFudEZvckVtb3Rpb24obmV3RW1vdGlvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIEZsaXAtQW5pbWF0aW9uOiBSYXVzIC0+IEJpbGQgd2VjaHNlbG4gLT4gUmVpblxuICAgIHNldElzUm90YXRpbmcodHJ1ZSk7XG4gICAgc2V0Um90YXRpb25QaGFzZSgnb3V0Jyk7XG4gICAgXG4gICAgLy8gTmFjaCBSYXVzLUFuaW1hdGlvbjogQmlsZCB3ZWNoc2VsblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgc2V0Q3VycmVudEVtb3Rpb24obmV3RW1vdGlvbik7XG4gICAgICBzZWxlY3RWYXJpYW50Rm9yRW1vdGlvbihuZXdFbW90aW9uKTtcbiAgICAgIHNldFJvdGF0aW9uUGhhc2UoJ2luJyk7XG4gICAgICBcbiAgICAgIC8vIE5hY2ggUmVpbi1BbmltYXRpb246IEFuaW1hdGlvbiBiZWVuZGVuXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgc2V0Um90YXRpb25QaGFzZSgnaWRsZScpO1xuICAgICAgICBzZXRJc1JvdGF0aW5nKGZhbHNlKTtcbiAgICAgIH0sIDMwMCk7XG4gICAgfSwgMzAwKTtcbiAgfTtcblxuICAvLyBBdXRvLVJlc2V0IGVudGZlcm50IC0gQ2hhcmFjdGVyIHdlY2hzZWx0IG51ciBiZWkgSW50ZXJha3Rpb25lblxuXG4gIC8vIENvbnRleHQtYWJow6RuZ2lnZSBFbW90aW9uZW4gbGFkZW5cbiAgY29uc3QgbG9hZENvbnRleHRFbW90aW9ucyA9IGFzeW5jIChjb250ZXh0KSA9PiB7XG4gICAgY29uc29sZS5sb2coYPCfjq0gbG9hZENvbnRleHRFbW90aW9ucyBjYWxsZWQgd2l0aCBjb250ZXh0OiAnJHtjb250ZXh0fScgKGxhc3RQcm9jZXNzZWQ6ICcke2xhc3RQcm9jZXNzZWRDb250ZXh0fScpYCk7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvY2hhcmFjdGVyL3JhbmRvbS1lbW90aW9uLyR7Y29udGV4dH1gKTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBcbiAgICAgIGlmIChkYXRhLmVtb3Rpb25zKSB7XG4gICAgICAgIHNldEF2YWlsYWJsZUVtb3Rpb25zKGRhdGEuZW1vdGlvbnMpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ29vbGRvd24gcHLDvGZlbjogS2VpbmUgRW1vdGlvbi1XZWNoc2VsIHdlbm4gZGVyIGxldHp0ZSB2b3Igd2VuaWdlciBhbHMgMiBTZWt1bmRlbiB3YXJcbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgdGltZVNpbmNlTGFzdENoYW5nZSA9IG5vdyAtIGxhc3RFbW90aW9uQ2hhbmdlVGltZTtcbiAgICAgICAgY29uc3QgRU1PVElPTl9DT09MRE9XTiA9IDIwMDA7IC8vIDIgU2VrdW5kZW4gQ29vbGRvd25cbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKGDwn46tIENvbnRleHQgY2hlY2s6IGNvbnRleHQ9JHtjb250ZXh0fSwgbGFzdFByb2Nlc3NlZD0ke2xhc3RQcm9jZXNzZWRDb250ZXh0fSwgY29vbGRvd249JHt0aW1lU2luY2VMYXN0Q2hhbmdlfW1zYCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoY29udGV4dCAhPT0gJ2lkbGUnICYmIGNvbnRleHQgIT09IGxhc3RQcm9jZXNzZWRDb250ZXh0ICYmIHRpbWVTaW5jZUxhc3RDaGFuZ2UgPj0gRU1PVElPTl9DT09MRE9XTikge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn46tIFRSSUdHRVJJTkcgZW1vdGlvbiBjaGFuZ2UgZm9yIGNvbnRleHQgJyR7Y29udGV4dH0nYCk7XG4gICAgICAgICAgY29uc3QgcmFuZG9tRW1vdGlvbiA9IGRhdGEuZW1vdGlvbnNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogZGF0YS5lbW90aW9ucy5sZW5ndGgpXTtcbiAgICAgICAgICBjaGFuZ2VFbW90aW9uKHJhbmRvbUVtb3Rpb24sIGZhbHNlKTsgLy8gTWl0IEZsaXAtQW5pbWF0aW9uXG4gICAgICAgICAgc2V0TGFzdFByb2Nlc3NlZENvbnRleHQoY29udGV4dCk7IC8vIE1lcmtlIGRhc3Mgd2lyIGRpZXNlbiBDb250ZXh0IHNjaG9uIHZlcmFyYmVpdGV0IGhhYmVuXG4gICAgICAgICAgc2V0TGFzdEVtb3Rpb25DaGFuZ2VUaW1lKG5vdyk7IC8vIFNldHplIENvb2xkb3duLVRpbWVyXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dCA9PT0gbGFzdFByb2Nlc3NlZENvbnRleHQpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhg8J+OrSBCTE9DS0VEOiBDb250ZXh0ICcke2NvbnRleHR9JyBhbHJlYWR5IHByb2Nlc3NlZGApO1xuICAgICAgICB9IGVsc2UgaWYgKHRpbWVTaW5jZUxhc3RDaGFuZ2UgPCBFTU9USU9OX0NPT0xET1dOKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYPCfjq0gQkxPQ0tFRDogQ29vbGRvd24gYWN0aXZlICgke3RpbWVTaW5jZUxhc3RDaGFuZ2V9bXMgPCAke0VNT1RJT05fQ09PTERPV059bXMpYCk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dCA9PT0gJ2lkbGUnKSB7XG4gICAgICAgICAgLy8gQmVpIGlkbGUtQ29udGV4dDogUmVzZXQgbGFzdFByb2Nlc3NlZENvbnRleHQgZsO8ciBuw6RjaHN0ZSBJbnRlcmFrdGlvbiAoYWJlciBrZWluIENvb2xkb3duIFJlc2V0KVxuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn46tIFJFU0VUOiBJZGxlIGNvbnRleHQsIGNsZWFyaW5nIGxhc3RQcm9jZXNzZWRDb250ZXh0YCk7XG4gICAgICAgICAgc2V0TGFzdFByb2Nlc3NlZENvbnRleHQobnVsbCk7XG4gICAgICAgICAgLy8gQ2hhcmFjdGVyIHdpcmQgTklDSFQgbmV1IGluc3RhbnppZXJ0LCBudXIgaGFzTG9hZGVkIGJsZWlidCB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBjb250ZXh0IGVtb3Rpb25zOicsIGVycm9yKTtcbiAgICAgIHNldEF2YWlsYWJsZUVtb3Rpb25zKFsnaWRsZScsICdjdXJpb3VzJ10pO1xuICAgIH1cbiAgfTtcblxuICAvLyBadWbDpGxsaWdlcyBMYWNoZW4gYWJzcGllbGVuIChvaG5lIFZvaWNlLU92ZXJzIHp1IHVudGVyYnJlY2hlbilcbiAgY29uc3QgcGxheVJhbmRvbUxhdWdodGVyID0gKCkgPT4ge1xuICAgIGNvbnN0IGxhdWdodGVyRmlsZXMgPSBbXG4gICAgICAnL2F1ZGlvL0xhdWdoaW5nS2lkL2xhdWdoaW5nLTEud2F2JyxcbiAgICAgICcvYXVkaW8vTGF1Z2hpbmdLaWQvbGF1Z2hpbmctMi53YXYnLFxuICAgICAgJy9hdWRpby9MYXVnaGluZ0tpZC9sYXVnaGluZy0zLndhdicsXG4gICAgICAnL2F1ZGlvL0xhdWdoaW5nS2lkL2xhdWdoaW5nLTQud2F2JyxcbiAgICAgICcvYXVkaW8vTGF1Z2hpbmdLaWQvbGF1Z2hpbmctNS53YXYnLFxuICAgICAgJy9hdWRpby9MYXVnaGluZ0tpZC9sYXVnaGluZy02LndhdicsXG4gICAgICAnL2F1ZGlvL0xhdWdoaW5nS2lkL2xhdWdoaW5nLTcud2F2J1xuICAgIF07XG4gICAgXG4gICAgLy8gWnVmw6RsbGlnZSBMYWNoZXItRGF0ZWkgYXVzd8OkaGxlblxuICAgIGNvbnN0IHJhbmRvbUxhdWdodGVyID0gbGF1Z2h0ZXJGaWxlc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBsYXVnaHRlckZpbGVzLmxlbmd0aCldO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBTRVBBUkFURVMgQXVkaW8tRWxlbWVudCBmw7xyIExhY2hlciAobmljaHQgZ2xvYmFsISlcbiAgICAgIGNvbnN0IGxhdWdodGVyQXVkaW8gPSBuZXcgQXVkaW8ocmFuZG9tTGF1Z2h0ZXIpO1xuICAgICAgbGF1Z2h0ZXJBdWRpby52b2x1bWUgPSAwLjc7IC8vIEV0d2FzIGxlaXNlciBhbHMgVm9pY2UtT3ZlcnNcbiAgICAgIFxuICAgICAgbGF1Z2h0ZXJBdWRpby5wbGF5KCkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ0xhY2hlci1BdWRpbyBhdXRvcGxheSB2ZXJoaW5kZXJ0OicsIGVycik7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ/CfpKMgTGFjaGVyIGFiZ2VzcGllbHQ6JywgcmFuZG9tTGF1Z2h0ZXIpO1xuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0xhY2hlci1BdWRpby1GZWhsZXI6JywgZXJyb3IpO1xuICAgIH1cbiAgfTtcblxuICAvLyBDaGFyYWN0ZXIgYW50aXBwZW4gLSBSb3RhdGlvbiwgRW1vdGlvbi1XZWNoc2VsIFVORCBMYWNoZW5cbiAgY29uc3QgaGFuZGxlQ2hhcmFjdGVyQ2xpY2sgPSAoKSA9PiB7XG4gICAgLy8gWnUgbGF1Z2hpbmcgb2RlciBleGNpdGVkIHdlY2hzZWxuLCBhYmVyIE5JRU1BTFMgZGllIGFrdHVlbGxlIEVtb3Rpb25cbiAgICBjb25zdCBoYXBweUVtb3Rpb25zID0gWydsYXVnaGluZycsICdleGNpdGVkJ107XG4gICAgbGV0IHJhbmRvbUhhcHB5RW1vdGlvbjtcbiAgICBcbiAgICAvLyBBbmRlcmUgRW1vdGlvbiB3w6RobGVuIGFscyBkaWUgYWt0dWVsbGVcbiAgICBpZiAoY3VycmVudEVtb3Rpb24gPT09ICdsYXVnaGluZycpIHtcbiAgICAgIHJhbmRvbUhhcHB5RW1vdGlvbiA9ICdleGNpdGVkJztcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRFbW90aW9uID09PSAnZXhjaXRlZCcpIHtcbiAgICAgIHJhbmRvbUhhcHB5RW1vdGlvbiA9ICdsYXVnaGluZyc7ICBcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV2VubiB3ZWRlciBsYXVnaGluZyBub2NoIGV4Y2l0ZWQsIHp1ZsOkbGxpZyB3w6RobGVuXG4gICAgICByYW5kb21IYXBweUVtb3Rpb24gPSBoYXBweUVtb3Rpb25zW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGhhcHB5RW1vdGlvbnMubGVuZ3RoKV07XG4gICAgfVxuICAgIFxuICAgIGNoYW5nZUVtb3Rpb24ocmFuZG9tSGFwcHlFbW90aW9uKTtcbiAgICBzZXRMYXN0RW1vdGlvbkNoYW5nZVRpbWUoRGF0ZS5ub3coKSk7IC8vIENvb2xkb3duLVRpbWVyIGF1Y2ggYmVpIGRpcmVrdGVtIENoYXJhY3Rlci1LbGljayBzZXR6ZW5cbiAgICBcbiAgICAvLyBadWbDpGxsaWdlcyBMYWNoZW4gYWJzcGllbGVuIChwYXJhbGxlbCB6dSBWb2ljZS1PdmVycylcbiAgICBwbGF5UmFuZG9tTGF1Z2h0ZXIoKTtcbiAgICBcbiAgICAvLyBDYWxsYmFjayBmw7xyIEVtb3Rpb24tw4RuZGVydW5nXG4gICAgaWYgKG9uRW1vdGlvbkNoYW5nZSkge1xuICAgICAgb25FbW90aW9uQ2hhbmdlKHJhbmRvbUhhcHB5RW1vdGlvbik7XG4gICAgfVxuICB9O1xuXG4gIC8vIEluaXRpYWwgRmx5LUluIEFuaW1hdGlvbiBzdGFydGVuIC0gTlVSIEVJTk1BTCBpbiBkZXIgZ2VzYW10ZW4gQXBwLUxhdWZ6ZWl0XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFjaGFyYWN0ZXJJbml0aWFsaXplZCkge1xuICAgICAgY29uc29sZS5sb2coYPCfjq0gQ2hhcmFjdGVyIEZJUlNUIFRJTUUgSU5JVElBTElaQVRJT05gKTtcbiAgICAgIGNoYXJhY3RlckluaXRpYWxpemVkID0gdHJ1ZTsgLy8gU2V0emUgc3RhdGlzY2hlIFZhcmlhYmxlXG4gICAgICBcbiAgICAgIC8vIE5hY2gga3VyemVyIFZlcnrDtmdlcnVuZyBDaGFyYWN0ZXIgcmVpbmZsaWVnZW4gbGFzc2VuXG4gICAgICBjb25zdCBsb2FkVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgc2V0SGFzTG9hZGVkKHRydWUpO1xuICAgICAgfSwgMzAwKTtcbiAgICAgIFxuICAgICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dChsb2FkVGltZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhg8J+OrSBDaGFyYWN0ZXIgQUxSRUFEWSBJTklUSUFMSVpFRCAtIHNraXBwaW5nIGZseS1pbmApO1xuICAgIH1cbiAgfSwgW10pO1xuXG4gIC8vIENvbnRleHQtw4RuZGVydW5nZW4gw7xiZXJ3YWNoZW4gLSBtaXQgUmVmIHVtIGRvcHBlbHRlIEF1ZnJ1ZmUgenUgdmVyaGluZGVyblxuICBjb25zdCBsYXN0Q29udGV4dFJlZiA9IHVzZVJlZihudWxsKTtcbiAgXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGN1cnJlbnRDb250ZXh0ICYmIGN1cnJlbnRDb250ZXh0ICE9PSBsYXN0Q29udGV4dFJlZi5jdXJyZW50KSB7XG4gICAgICBjb25zb2xlLmxvZyhg8J+OrSBQcm9jZXNzaW5nIE5FVyBjb250ZXh0OiAnJHtjdXJyZW50Q29udGV4dH0nYCk7XG4gICAgICBsYXN0Q29udGV4dFJlZi5jdXJyZW50ID0gY3VycmVudENvbnRleHQ7XG4gICAgICBsb2FkQ29udGV4dEVtb3Rpb25zKGN1cnJlbnRDb250ZXh0KTtcbiAgICB9XG4gIH0sIFtjdXJyZW50Q29udGV4dF0pO1xuXG4gIC8vIENsZWFudXAgVGltZXJcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKGF1dG9SZXNldFRpbWVyLmN1cnJlbnQpIGNsZWFyVGltZW91dChhdXRvUmVzZXRUaW1lci5jdXJyZW50KTtcbiAgICAgIGlmIChlbW90aW9uQ2hhbmdlVGltZXIuY3VycmVudCkgY2xlYXJUaW1lb3V0KGVtb3Rpb25DaGFuZ2VUaW1lci5jdXJyZW50KTtcbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgLy8gQW5pbWF0aW9uLUtsYXNzZW4gYmVzdGltbWVuXG4gIGNvbnN0IGdldEFuaW1hdGlvbkNsYXNzZXMgPSAoKSA9PiB7XG4gICAgbGV0IGNsYXNzZXMgPSAnY2hhcmFjdGVyLWltYWdlJztcbiAgICBcbiAgICAvLyBJbml0aWFsIEZseS1JbiBBbmltYXRpb24gYmVpbSBlcnN0ZW4gTGFkZW5cbiAgICBpZiAoIWhhc0xvYWRlZCkge1xuICAgICAgY2xhc3NlcyArPSAnIGNoYXJhY3Rlci1mbHktaW4nO1xuICAgICAgcmV0dXJuIGNsYXNzZXM7XG4gICAgfVxuICAgIFxuICAgIGlmIChyb3RhdGlvblBoYXNlID09PSAnb3V0Jykge1xuICAgICAgY2xhc3NlcyArPSAnIGNoYXJhY3Rlci1yb3RhdGUtb3V0JztcbiAgICB9IGVsc2UgaWYgKHJvdGF0aW9uUGhhc2UgPT09ICdpbicpIHtcbiAgICAgIGNsYXNzZXMgKz0gJyBjaGFyYWN0ZXItcm90YXRlLWluJztcbiAgICB9XG4gICAgXG4gICAgLy8gU3VidGlsZSBMb29wLUFuaW1hdGlvbiB3ZW5uIGtlaW5lIFJvdGF0aW9uIGzDpHVmdFxuICAgIGlmIChyb3RhdGlvblBoYXNlID09PSAnaWRsZScpIHtcbiAgICAgIGNsYXNzZXMgKz0gJyBjaGFyYWN0ZXItc3VidGxlLWFuaW1hdGlvbic7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBjbGFzc2VzO1xuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBcbiAgICAgIGNsYXNzTmFtZT1cImNoYXJhY3Rlci1jb250YWluZXJcIlxuICAgICAgb25DbGljaz17aGFuZGxlQ2hhcmFjdGVyQ2xpY2t9XG4gICAgICB0aXRsZT1cIkNoYXJhY3RlciBhbnRpcHBlbiBmw7xyIEVtb3Rpb25lbiFcIlxuICAgID5cbiAgICAgIDxJbWFnZVxuICAgICAgICBzcmM9e3NlbGVjdGVkVmFyaWFudH1cbiAgICAgICAgYWx0PXtgQ2hhcmFjdGVyICR7Y3VycmVudEVtb3Rpb259YH1cbiAgICAgICAgd2lkdGg9ezEyMH1cbiAgICAgICAgaGVpZ2h0PXsxNTB9XG4gICAgICAgIGNsYXNzTmFtZT17Z2V0QW5pbWF0aW9uQ2xhc3NlcygpfVxuICAgICAgICBwcmlvcml0eVxuICAgICAgICB1bm9wdGltaXplZCAvLyBGw7xyIGxva2FsZSBFbnR3aWNrbHVuZ1xuICAgICAgLz5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IENoYXJhY3RlcjsgXG4vLyBDYWNoZS1SZWZyZXNoOiBVcGRhdGVkIENoYXJhY3RlciBBbmltYXRpb24gYW5kIHJlbW92ZWQgaXNCb3VuY2luZyAiXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJJbWFnZSIsImNoYXJhY3RlckluaXRpYWxpemVkIiwiQ2hhcmFjdGVyIiwiY3VycmVudENvbnRleHQiLCJvbkVtb3Rpb25DaGFuZ2UiLCJjdXJyZW50RW1vdGlvbiIsInNldEN1cnJlbnRFbW90aW9uIiwiaXNSb3RhdGluZyIsInNldElzUm90YXRpbmciLCJyb3RhdGlvblBoYXNlIiwic2V0Um90YXRpb25QaGFzZSIsImF2YWlsYWJsZUVtb3Rpb25zIiwic2V0QXZhaWxhYmxlRW1vdGlvbnMiLCJoYXNMb2FkZWQiLCJzZXRIYXNMb2FkZWQiLCJsYXN0UHJvY2Vzc2VkQ29udGV4dCIsInNldExhc3RQcm9jZXNzZWRDb250ZXh0IiwibGFzdEVtb3Rpb25DaGFuZ2VUaW1lIiwic2V0TGFzdEVtb3Rpb25DaGFuZ2VUaW1lIiwiYXV0b1Jlc2V0VGltZXIiLCJlbW90aW9uQ2hhbmdlVGltZXIiLCJjaGFyYWN0ZXJWYXJpYW50cyIsImlkbGUiLCJleGNpdGVkIiwiY3VyaW91cyIsInN1cnByaXNlZCIsInRoaW5raW5nIiwibGF1Z2hpbmciLCJleHBsb3JpbmciLCJzY2FyZWQiLCJzZWxlY3RlZFZhcmlhbnQiLCJzZXRTZWxlY3RlZFZhcmlhbnQiLCJzZWxlY3RWYXJpYW50Rm9yRW1vdGlvbiIsImVtb3Rpb24iLCJ2YXJpYW50cyIsImxlbmd0aCIsInZhcmlhbnQiLCJvdGhlclZhcmlhbnRzIiwiZmlsdGVyIiwicmFuZG9tVmFyaWFudCIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsImdldFJhbmRvbUVtb3Rpb24iLCJlbW90aW9ucyIsImZpbHRlcmVkIiwiZSIsImNoYW5nZUVtb3Rpb24iLCJuZXdFbW90aW9uIiwiaW1tZWRpYXRlIiwiY29uc29sZSIsImxvZyIsInNldFRpbWVvdXQiLCJsb2FkQ29udGV4dEVtb3Rpb25zIiwiY29udGV4dCIsInJlc3BvbnNlIiwiZmV0Y2giLCJkYXRhIiwianNvbiIsIm5vdyIsIkRhdGUiLCJ0aW1lU2luY2VMYXN0Q2hhbmdlIiwiRU1PVElPTl9DT09MRE9XTiIsInJhbmRvbUVtb3Rpb24iLCJlcnJvciIsInBsYXlSYW5kb21MYXVnaHRlciIsImxhdWdodGVyRmlsZXMiLCJyYW5kb21MYXVnaHRlciIsImxhdWdodGVyQXVkaW8iLCJBdWRpbyIsInZvbHVtZSIsInBsYXkiLCJjYXRjaCIsImVyciIsImhhbmRsZUNoYXJhY3RlckNsaWNrIiwiaGFwcHlFbW90aW9ucyIsInJhbmRvbUhhcHB5RW1vdGlvbiIsImxvYWRUaW1lciIsImNsZWFyVGltZW91dCIsImxhc3RDb250ZXh0UmVmIiwiY3VycmVudCIsImdldEFuaW1hdGlvbkNsYXNzZXMiLCJjbGFzc2VzIiwiZGl2IiwiY2xhc3NOYW1lIiwib25DbGljayIsInRpdGxlIiwic3JjIiwiYWx0Iiwid2lkdGgiLCJoZWlnaHQiLCJwcmlvcml0eSIsInVub3B0aW1pemVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./components/Character.js\n"));

/***/ })

});