"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./components/Character.js":
/*!*********************************!*\
  !*** ./components/Character.js ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/image */ \"./node_modules/next/image.js\");\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_image__WEBPACK_IMPORTED_MODULE_2__);\n\nvar _s = $RefreshSig$();\n\n\nconst Character = (param)=>{\n    let { currentContext = \"idle\", onEmotionChange } = param;\n    _s();\n    const [currentEmotion, setCurrentEmotion] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"idle\");\n    const [isRotating, setIsRotating] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [rotationPhase, setRotationPhase] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"idle\"); // 'idle', 'out', 'in'\n    const [availableEmotions, setAvailableEmotions] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([\n        \"idle\",\n        \"curious\"\n    ]);\n    const [hasLoaded, setHasLoaded] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false); // Für initiale Fly-In Animation\n    const [lastProcessedContext, setLastProcessedContext] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null); // Verhindert mehrfache Emotion-Wechsel\n    const [lastEmotionChangeTime, setLastEmotionChangeTime] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0); // Cooldown für Emotion-Changes\n    const autoResetTimer = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const emotionChangeTimer = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Character-Bilder-Varianten definieren\n    const characterVariants = {\n        idle: [\n            \"/Characters/Character-idle.png\",\n            \"/Characters/Character-idle-2.png\",\n            \"/Characters/Character-idle-3.png\"\n        ],\n        excited: [\n            \"/Characters/Character-excited.png\",\n            \"/Characters/Character-excited-2.png\",\n            \"/Characters/Character-excited-3.png\"\n        ],\n        curious: [\n            \"/Characters/Character-curious.png\",\n            \"/Characters/Character-curious-2.png\",\n            \"/Characters/Character-curious-3.png\"\n        ],\n        surprised: [\n            \"/Characters/Character-surprised.png\",\n            \"/Characters/Character-surprised-2.png\",\n            \"/Characters/Character-surprised-3.png\"\n        ],\n        thinking: [\n            \"/Characters/Character-thinking.png\",\n            \"/Characters/Character-thinking-2.png\",\n            \"/Characters/Character-thinking-3.png\"\n        ],\n        laughing: [\n            \"/Characters/Character-laughing.png\",\n            \"/Characters/Character-laughing-2.png\"\n        ],\n        exploring: [\n            \"/Characters/Character-excited.png\",\n            \"/Characters/Character-excited-2.png\",\n            \"/Characters/Character-excited-3.png\"\n        ],\n        scared: [\n            \"/Characters/Character-surprised.png\",\n            \"/Characters/Character-surprised-2.png\",\n            \"/Characters/Character-surprised-3.png\"\n        ]\n    };\n    // State für gewählte Variante pro Emotion\n    const [selectedVariant, setSelectedVariant] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"/Characters/Character-idle.png\");\n    // Zufällige Variante für Emotion wählen und speichern (NIEMALS die gleiche)\n    const selectVariantForEmotion = (emotion)=>{\n        const variants = characterVariants[emotion] || characterVariants.idle;\n        // Wenn nur eine Variante vorhanden, diese nehmen\n        if (variants.length === 1) {\n            const variant = variants[0];\n            setSelectedVariant(variant);\n            return variant;\n        }\n        // Aktuelle Variante rausfiltern um Wiederholung zu vermeiden\n        const otherVariants = variants.filter((variant)=>variant !== selectedVariant);\n        // Falls alle Varianten die gleiche sind (sollte nicht passieren), erste nehmen\n        if (otherVariants.length === 0) {\n            const variant = variants[0];\n            setSelectedVariant(variant);\n            return variant;\n        }\n        // Zufällige andere Variante wählen\n        const randomVariant = otherVariants[Math.floor(Math.random() * otherVariants.length)];\n        setSelectedVariant(randomVariant);\n        return randomVariant;\n    };\n    // Zufällige Emotion aus verfügbaren Emotionen wählen\n    const getRandomEmotion = function() {\n        let emotions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : availableEmotions;\n        const filtered = emotions.filter((e)=>e !== currentEmotion);\n        if (filtered.length === 0) return emotions[0];\n        return filtered[Math.floor(Math.random() * filtered.length)];\n    };\n    // Rotation Animation mit Emotion-Wechsel\n    const changeEmotion = function(newEmotion) {\n        let immediate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        console.log(\"\\uD83C\\uDFAD changeEmotion called: \".concat(currentEmotion, \" -> \").concat(newEmotion, \", immediate: \").concat(immediate));\n        if (newEmotion === currentEmotion && !immediate) {\n            console.log(\"\\uD83C\\uDFAD BLOCKED: Same emotion \".concat(newEmotion, \", no change needed\"));\n            return;\n        }\n        if (immediate) {\n            console.log(\"\\uD83C\\uDFAD IMMEDIATE: Setting emotion to \".concat(newEmotion));\n            setCurrentEmotion(newEmotion);\n            selectVariantForEmotion(newEmotion);\n            return;\n        }\n        console.log(\"\\uD83C\\uDFAD ANIMATED: Starting rotation \".concat(currentEmotion, \" -> \").concat(newEmotion));\n        // Start rotate-out\n        setIsRotating(true);\n        setRotationPhase(\"out\");\n        // Nach 150ms (halbe Rotation) Emotion wechseln und rotate-in starten - doppelt so schnell\n        emotionChangeTimer.current = setTimeout(()=>{\n            console.log(\"\\uD83C\\uDFAD MID-ROTATION: Setting emotion to \".concat(newEmotion));\n            setCurrentEmotion(newEmotion);\n            selectVariantForEmotion(newEmotion); // Neue Variante wählen\n            setRotationPhase(\"in\");\n            // Nach weiteren 150ms Rotation vollständig beenden - doppelt so schnell\n            setTimeout(()=>{\n                setIsRotating(false);\n                setRotationPhase(\"idle\");\n                console.log(\"\\uD83C\\uDFAD ROTATION COMPLETE: Now \".concat(newEmotion));\n            }, 150);\n        }, 150);\n    };\n    // Auto-Reset entfernt - Character wechselt nur bei Interaktionen\n    // Context-abhängige Emotionen laden\n    const loadContextEmotions = async (context)=>{\n        console.log(\"\\uD83C\\uDFAD loadContextEmotions called with context: '\".concat(context, \"' (lastProcessed: '\").concat(lastProcessedContext, \"')\"));\n        try {\n            const response = await fetch(\"/api/character/random-emotion/\".concat(context));\n            const data = await response.json();\n            if (data.emotions) {\n                setAvailableEmotions(data.emotions);\n                // Cooldown prüfen: Keine Emotion-Wechsel wenn der letzte vor weniger als 2 Sekunden war\n                const now = Date.now();\n                const timeSinceLastChange = now - lastEmotionChangeTime;\n                const EMOTION_COOLDOWN = 2000; // 2 Sekunden Cooldown\n                console.log(\"\\uD83C\\uDFAD Context check: context=\".concat(context, \", lastProcessed=\").concat(lastProcessedContext, \", cooldown=\").concat(timeSinceLastChange, \"ms\"));\n                if (context !== \"idle\" && context !== lastProcessedContext && timeSinceLastChange >= EMOTION_COOLDOWN) {\n                    console.log(\"\\uD83C\\uDFAD TRIGGERING emotion change for context '\".concat(context, \"'\"));\n                    const randomEmotion = data.emotions[Math.floor(Math.random() * data.emotions.length)];\n                    changeEmotion(randomEmotion, false);\n                    setLastProcessedContext(context); // Merke dass wir diesen Context schon verarbeitet haben\n                    setLastEmotionChangeTime(now); // Setze Cooldown-Timer\n                } else if (context === lastProcessedContext) {\n                    console.log(\"\\uD83C\\uDFAD BLOCKED: Context '\".concat(context, \"' already processed\"));\n                } else if (timeSinceLastChange < EMOTION_COOLDOWN) {\n                    console.log(\"\\uD83C\\uDFAD BLOCKED: Cooldown active (\".concat(timeSinceLastChange, \"ms < \").concat(EMOTION_COOLDOWN, \"ms)\"));\n                } else if (context === \"idle\") {\n                    // Bei idle-Context: Reset lastProcessedContext für nächste Interaktion (aber kein Cooldown Reset)\n                    console.log(\"\\uD83C\\uDFAD RESET: Idle context, clearing lastProcessedContext\");\n                    setLastProcessedContext(null);\n                // Character wird NICHT neu instanziert, nur hasLoaded bleibt true\n                }\n            }\n        } catch (error) {\n            console.error(\"Error loading context emotions:\", error);\n            setAvailableEmotions([\n                \"idle\",\n                \"curious\"\n            ]);\n        }\n    };\n    // Zufälliges Lachen abspielen (ohne Voice-Overs zu unterbrechen)\n    const playRandomLaughter = ()=>{\n        const laughterFiles = [\n            \"/audio/LaughingKid/laughing-1.wav\",\n            \"/audio/LaughingKid/laughing-2.wav\",\n            \"/audio/LaughingKid/laughing-3.wav\",\n            \"/audio/LaughingKid/laughing-4.wav\",\n            \"/audio/LaughingKid/laughing-5.wav\",\n            \"/audio/LaughingKid/laughing-6.wav\",\n            \"/audio/LaughingKid/laughing-7.wav\"\n        ];\n        // Zufällige Lacher-Datei auswählen\n        const randomLaughter = laughterFiles[Math.floor(Math.random() * laughterFiles.length)];\n        try {\n            // SEPARATES Audio-Element für Lacher (nicht global!)\n            const laughterAudio = new Audio(randomLaughter);\n            laughterAudio.volume = 0.7; // Etwas leiser als Voice-Overs\n            laughterAudio.play().catch((err)=>{\n                console.log(\"Lacher-Audio autoplay verhindert:\", err);\n            });\n            console.log(\"\\uD83E\\uDD23 Lacher abgespielt:\", randomLaughter);\n        } catch (error) {\n            console.error(\"Lacher-Audio-Fehler:\", error);\n        }\n    };\n    // Character antippen - Rotation, Emotion-Wechsel UND Lachen\n    const handleCharacterClick = ()=>{\n        // Zu laughing oder excited wechseln, aber NIEMALS die aktuelle Emotion\n        const happyEmotions = [\n            \"laughing\",\n            \"excited\"\n        ];\n        let randomHappyEmotion;\n        // Andere Emotion wählen als die aktuelle\n        if (currentEmotion === \"laughing\") {\n            randomHappyEmotion = \"excited\";\n        } else if (currentEmotion === \"excited\") {\n            randomHappyEmotion = \"laughing\";\n        } else {\n            // Wenn weder laughing noch excited, zufällig wählen\n            randomHappyEmotion = happyEmotions[Math.floor(Math.random() * happyEmotions.length)];\n        }\n        changeEmotion(randomHappyEmotion);\n        setLastEmotionChangeTime(Date.now()); // Cooldown-Timer auch bei direktem Character-Klick setzen\n        // Zufälliges Lachen abspielen (parallel zu Voice-Overs)\n        playRandomLaughter();\n        // Callback für Emotion-Änderung\n        if (onEmotionChange) {\n            onEmotionChange(randomHappyEmotion);\n        }\n    };\n    // Initial Fly-In Animation starten - NUR EINMAL beim ersten Mount\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // Nach kurzer Verzögerung Character reinfliegen lassen\n        const loadTimer = setTimeout(()=>{\n            setHasLoaded(true);\n        }, 300);\n        return ()=>clearTimeout(loadTimer);\n    }, []); // Leeres Array - NUR beim ersten Mount\n    // Debug: Character Mount/Unmount tracking\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        console.log(\"\\uD83C\\uDFAD Character MOUNTED/RE-MOUNTED\");\n        return ()=>{\n            console.log(\"\\uD83C\\uDFAD Character UNMOUNTED\");\n        };\n    }, []);\n    // Context-Änderungen überwachen - mit Ref um doppelte Aufrufe zu verhindern\n    const lastContextRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        console.log(\"\\uD83C\\uDFAD useEffect triggered: currentContext='\".concat(currentContext, \"', lastContextRef='\").concat(lastContextRef.current, \"'\"));\n        if (currentContext && currentContext !== lastContextRef.current) {\n            console.log(\"\\uD83C\\uDFAD useEffect: Processing NEW context '\".concat(currentContext, \"'\"));\n            lastContextRef.current = currentContext;\n            loadContextEmotions(currentContext);\n        } else if (currentContext === lastContextRef.current) {\n            console.log(\"\\uD83C\\uDFAD useEffect: IGNORING duplicate context '\".concat(currentContext, \"'\"));\n        }\n    }, [\n        currentContext\n    ]);\n    // Cleanup Timer\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        return ()=>{\n            if (autoResetTimer.current) clearTimeout(autoResetTimer.current);\n            if (emotionChangeTimer.current) clearTimeout(emotionChangeTimer.current);\n        };\n    }, []);\n    // Animation-Klassen bestimmen\n    const getAnimationClasses = ()=>{\n        let classes = \"character-image\";\n        // Initial Fly-In Animation beim ersten Laden\n        if (!hasLoaded) {\n            classes += \" character-fly-in\";\n            return classes;\n        }\n        if (rotationPhase === \"out\") {\n            classes += \" character-rotate-out\";\n        } else if (rotationPhase === \"in\") {\n            classes += \" character-rotate-in\";\n        }\n        // Subtile Loop-Animation wenn keine Rotation läuft\n        if (rotationPhase === \"idle\") {\n            classes += \" character-subtle-animation\";\n        }\n        return classes;\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"character-container\",\n        onClick: handleCharacterClick,\n        title: \"Character antippen f\\xfcr Emotionen!\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_image__WEBPACK_IMPORTED_MODULE_2___default()), {\n            src: selectedVariant,\n            alt: \"Character \".concat(currentEmotion),\n            width: 120,\n            height: 150,\n            className: getAnimationClasses(),\n            priority: true,\n            unoptimized: true\n        }, void 0, false, {\n            fileName: \"D:\\\\gitrepros\\\\Vorschulkinder Lexikon\\\\components\\\\Character.js\",\n            lineNumber: 306,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"D:\\\\gitrepros\\\\Vorschulkinder Lexikon\\\\components\\\\Character.js\",\n        lineNumber: 301,\n        columnNumber: 5\n    }, undefined);\n};\n_s(Character, \"RcWl0fHSrKrmx70C4a2/vdmYa5M=\");\n_c = Character;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Character); // Cache-Refresh: Updated Character Animation and removed isBouncing \nvar _c;\n$RefreshReg$(_c, \"Character\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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WUFDNUJ5RSxXQUFXO1FBQ2I7UUFFQSxPQUFPQTtJQUNUO0lBRUEscUJBQ0UsOERBQUNDO1FBQ0NDLFdBQVU7UUFDVkMsU0FBU1Y7UUFDVFcsT0FBTTtrQkFFTiw0RUFBQ3JGLG1EQUFLQTtZQUNKc0YsS0FBS3pEO1lBQ0wwRCxLQUFLLGFBQTRCLE9BQWZuRjtZQUNsQm9GLE9BQU87WUFDUEMsUUFBUTtZQUNSTixXQUFXSDtZQUNYVSxRQUFRO1lBQ1JDLFdBQVc7Ozs7Ozs7Ozs7O0FBSW5CO0dBelRNMUY7S0FBQUE7QUEyVE4sK0RBQWVBLFNBQVNBLEVBQUMsQ0FDekIscUVBQXFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvQ2hhcmFjdGVyLmpzP2UyN2YiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IEltYWdlIGZyb20gJ25leHQvaW1hZ2UnO1xuXG5jb25zdCBDaGFyYWN0ZXIgPSAoeyBjdXJyZW50Q29udGV4dCA9ICdpZGxlJywgb25FbW90aW9uQ2hhbmdlIH0pID0+IHtcbiAgY29uc3QgW2N1cnJlbnRFbW90aW9uLCBzZXRDdXJyZW50RW1vdGlvbl0gPSB1c2VTdGF0ZSgnaWRsZScpO1xuICBjb25zdCBbaXNSb3RhdGluZywgc2V0SXNSb3RhdGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtyb3RhdGlvblBoYXNlLCBzZXRSb3RhdGlvblBoYXNlXSA9IHVzZVN0YXRlKCdpZGxlJyk7IC8vICdpZGxlJywgJ291dCcsICdpbidcbiAgY29uc3QgW2F2YWlsYWJsZUVtb3Rpb25zLCBzZXRBdmFpbGFibGVFbW90aW9uc10gPSB1c2VTdGF0ZShbJ2lkbGUnLCAnY3VyaW91cyddKTtcbiAgY29uc3QgW2hhc0xvYWRlZCwgc2V0SGFzTG9hZGVkXSA9IHVzZVN0YXRlKGZhbHNlKTsgLy8gRsO8ciBpbml0aWFsZSBGbHktSW4gQW5pbWF0aW9uXG4gIGNvbnN0IFtsYXN0UHJvY2Vzc2VkQ29udGV4dCwgc2V0TGFzdFByb2Nlc3NlZENvbnRleHRdID0gdXNlU3RhdGUobnVsbCk7IC8vIFZlcmhpbmRlcnQgbWVocmZhY2hlIEVtb3Rpb24tV2VjaHNlbFxuICBjb25zdCBbbGFzdEVtb3Rpb25DaGFuZ2VUaW1lLCBzZXRMYXN0RW1vdGlvbkNoYW5nZVRpbWVdID0gdXNlU3RhdGUoMCk7IC8vIENvb2xkb3duIGbDvHIgRW1vdGlvbi1DaGFuZ2VzXG4gIFxuICBjb25zdCBhdXRvUmVzZXRUaW1lciA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgZW1vdGlvbkNoYW5nZVRpbWVyID0gdXNlUmVmKG51bGwpO1xuXG4gIC8vIENoYXJhY3Rlci1CaWxkZXItVmFyaWFudGVuIGRlZmluaWVyZW5cbiAgY29uc3QgY2hhcmFjdGVyVmFyaWFudHMgPSB7XG4gICAgaWRsZTogW1xuICAgICAgJy9DaGFyYWN0ZXJzL0NoYXJhY3Rlci1pZGxlLnBuZycsXG4gICAgICAnL0NoYXJhY3RlcnMvQ2hhcmFjdGVyLWlkbGUtMi5wbmcnLFxuICAgICAgJy9DaGFyYWN0ZXJzL0NoYXJhY3Rlci1pZGxlLTMucG5nJ1xuICAgIF0sXG4gICAgZXhjaXRlZDogW1xuICAgICAgJy9DaGFyYWN0ZXJzL0NoYXJhY3Rlci1leGNpdGVkLnBuZycsXG4gICAgICAnL0NoYXJhY3RlcnMvQ2hhcmFjdGVyLWV4Y2l0ZWQtMi5wbmcnLFxuICAgICAgJy9DaGFyYWN0ZXJzL0NoYXJhY3Rlci1leGNpdGVkLTMucG5nJ1xuICAgIF0sXG4gICAgY3VyaW91czogW1xuICAgICAgJy9DaGFyYWN0ZXJzL0NoYXJhY3Rlci1jdXJpb3VzLnBuZycsXG4gICAgICAnL0NoYXJhY3RlcnMvQ2hhcmFjdGVyLWN1cmlvdXMtMi5wbmcnLFxuICAgICAgJy9DaGFyYWN0ZXJzL0NoYXJhY3Rlci1jdXJpb3VzLTMucG5nJ1xuICAgIF0sXG4gICAgc3VycHJpc2VkOiBbXG4gICAgICAnL0NoYXJhY3RlcnMvQ2hhcmFjdGVyLXN1cnByaXNlZC5wbmcnLFxuICAgICAgJy9DaGFyYWN0ZXJzL0NoYXJhY3Rlci1zdXJwcmlzZWQtMi5wbmcnLFxuICAgICAgJy9DaGFyYWN0ZXJzL0NoYXJhY3Rlci1zdXJwcmlzZWQtMy5wbmcnXG4gICAgXSxcbiAgICB0aGlua2luZzogW1xuICAgICAgJy9DaGFyYWN0ZXJzL0NoYXJhY3Rlci10aGlua2luZy5wbmcnLFxuICAgICAgJy9DaGFyYWN0ZXJzL0NoYXJhY3Rlci10aGlua2luZy0yLnBuZycsXG4gICAgICAnL0NoYXJhY3RlcnMvQ2hhcmFjdGVyLXRoaW5raW5nLTMucG5nJ1xuICAgIF0sXG4gICAgbGF1Z2hpbmc6IFtcbiAgICAgICcvQ2hhcmFjdGVycy9DaGFyYWN0ZXItbGF1Z2hpbmcucG5nJyxcbiAgICAgICcvQ2hhcmFjdGVycy9DaGFyYWN0ZXItbGF1Z2hpbmctMi5wbmcnXG4gICAgXSxcbiAgICBleHBsb3Jpbmc6IFtcbiAgICAgICcvQ2hhcmFjdGVycy9DaGFyYWN0ZXItZXhjaXRlZC5wbmcnLFxuICAgICAgJy9DaGFyYWN0ZXJzL0NoYXJhY3Rlci1leGNpdGVkLTIucG5nJyxcbiAgICAgICcvQ2hhcmFjdGVycy9DaGFyYWN0ZXItZXhjaXRlZC0zLnBuZydcbiAgICBdLFxuICAgIHNjYXJlZDogW1xuICAgICAgJy9DaGFyYWN0ZXJzL0NoYXJhY3Rlci1zdXJwcmlzZWQucG5nJyxcbiAgICAgICcvQ2hhcmFjdGVycy9DaGFyYWN0ZXItc3VycHJpc2VkLTIucG5nJyxcbiAgICAgICcvQ2hhcmFjdGVycy9DaGFyYWN0ZXItc3VycHJpc2VkLTMucG5nJ1xuICAgIF0sXG4gIH07XG5cbiAgLy8gU3RhdGUgZsO8ciBnZXfDpGhsdGUgVmFyaWFudGUgcHJvIEVtb3Rpb25cbiAgY29uc3QgW3NlbGVjdGVkVmFyaWFudCwgc2V0U2VsZWN0ZWRWYXJpYW50XSA9IHVzZVN0YXRlKCcvQ2hhcmFjdGVycy9DaGFyYWN0ZXItaWRsZS5wbmcnKTtcblxuICAvLyBadWbDpGxsaWdlIFZhcmlhbnRlIGbDvHIgRW1vdGlvbiB3w6RobGVuIHVuZCBzcGVpY2hlcm4gKE5JRU1BTFMgZGllIGdsZWljaGUpXG4gIGNvbnN0IHNlbGVjdFZhcmlhbnRGb3JFbW90aW9uID0gKGVtb3Rpb24pID0+IHtcbiAgICBjb25zdCB2YXJpYW50cyA9IGNoYXJhY3RlclZhcmlhbnRzW2Vtb3Rpb25dIHx8IGNoYXJhY3RlclZhcmlhbnRzLmlkbGU7XG4gICAgXG4gICAgLy8gV2VubiBudXIgZWluZSBWYXJpYW50ZSB2b3JoYW5kZW4sIGRpZXNlIG5laG1lblxuICAgIGlmICh2YXJpYW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IHZhcmlhbnQgPSB2YXJpYW50c1swXTtcbiAgICAgIHNldFNlbGVjdGVkVmFyaWFudCh2YXJpYW50KTtcbiAgICAgIHJldHVybiB2YXJpYW50O1xuICAgIH1cbiAgICBcbiAgICAvLyBBa3R1ZWxsZSBWYXJpYW50ZSByYXVzZmlsdGVybiB1bSBXaWVkZXJob2x1bmcgenUgdmVybWVpZGVuXG4gICAgY29uc3Qgb3RoZXJWYXJpYW50cyA9IHZhcmlhbnRzLmZpbHRlcih2YXJpYW50ID0+IHZhcmlhbnQgIT09IHNlbGVjdGVkVmFyaWFudCk7XG4gICAgXG4gICAgLy8gRmFsbHMgYWxsZSBWYXJpYW50ZW4gZGllIGdsZWljaGUgc2luZCAoc29sbHRlIG5pY2h0IHBhc3NpZXJlbiksIGVyc3RlIG5laG1lblxuICAgIGlmIChvdGhlclZhcmlhbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc3QgdmFyaWFudCA9IHZhcmlhbnRzWzBdO1xuICAgICAgc2V0U2VsZWN0ZWRWYXJpYW50KHZhcmlhbnQpO1xuICAgICAgcmV0dXJuIHZhcmlhbnQ7XG4gICAgfVxuICAgIFxuICAgIC8vIFp1ZsOkbGxpZ2UgYW5kZXJlIFZhcmlhbnRlIHfDpGhsZW5cbiAgICBjb25zdCByYW5kb21WYXJpYW50ID0gb3RoZXJWYXJpYW50c1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBvdGhlclZhcmlhbnRzLmxlbmd0aCldO1xuICAgIHNldFNlbGVjdGVkVmFyaWFudChyYW5kb21WYXJpYW50KTtcbiAgICByZXR1cm4gcmFuZG9tVmFyaWFudDtcbiAgfTtcblxuICAvLyBadWbDpGxsaWdlIEVtb3Rpb24gYXVzIHZlcmbDvGdiYXJlbiBFbW90aW9uZW4gd8OkaGxlblxuICBjb25zdCBnZXRSYW5kb21FbW90aW9uID0gKGVtb3Rpb25zID0gYXZhaWxhYmxlRW1vdGlvbnMpID0+IHtcbiAgICBjb25zdCBmaWx0ZXJlZCA9IGVtb3Rpb25zLmZpbHRlcihlID0+IGUgIT09IGN1cnJlbnRFbW90aW9uKTtcbiAgICBpZiAoZmlsdGVyZWQubGVuZ3RoID09PSAwKSByZXR1cm4gZW1vdGlvbnNbMF07XG4gICAgcmV0dXJuIGZpbHRlcmVkW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGZpbHRlcmVkLmxlbmd0aCldO1xuICB9O1xuXG4gIC8vIFJvdGF0aW9uIEFuaW1hdGlvbiBtaXQgRW1vdGlvbi1XZWNoc2VsXG4gIGNvbnN0IGNoYW5nZUVtb3Rpb24gPSAobmV3RW1vdGlvbiwgaW1tZWRpYXRlID0gZmFsc2UpID0+IHtcbiAgICBjb25zb2xlLmxvZyhg8J+OrSBjaGFuZ2VFbW90aW9uIGNhbGxlZDogJHtjdXJyZW50RW1vdGlvbn0gLT4gJHtuZXdFbW90aW9ufSwgaW1tZWRpYXRlOiAke2ltbWVkaWF0ZX1gKTtcbiAgICBcbiAgICBpZiAobmV3RW1vdGlvbiA9PT0gY3VycmVudEVtb3Rpb24gJiYgIWltbWVkaWF0ZSkge1xuICAgICAgY29uc29sZS5sb2coYPCfjq0gQkxPQ0tFRDogU2FtZSBlbW90aW9uICR7bmV3RW1vdGlvbn0sIG5vIGNoYW5nZSBuZWVkZWRgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgaWYgKGltbWVkaWF0ZSkge1xuICAgICAgY29uc29sZS5sb2coYPCfjq0gSU1NRURJQVRFOiBTZXR0aW5nIGVtb3Rpb24gdG8gJHtuZXdFbW90aW9ufWApO1xuICAgICAgc2V0Q3VycmVudEVtb3Rpb24obmV3RW1vdGlvbik7XG4gICAgICBzZWxlY3RWYXJpYW50Rm9yRW1vdGlvbihuZXdFbW90aW9uKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhg8J+OrSBBTklNQVRFRDogU3RhcnRpbmcgcm90YXRpb24gJHtjdXJyZW50RW1vdGlvbn0gLT4gJHtuZXdFbW90aW9ufWApO1xuICAgIC8vIFN0YXJ0IHJvdGF0ZS1vdXRcbiAgICBzZXRJc1JvdGF0aW5nKHRydWUpO1xuICAgIHNldFJvdGF0aW9uUGhhc2UoJ291dCcpO1xuICAgIFxuICAgIC8vIE5hY2ggMTUwbXMgKGhhbGJlIFJvdGF0aW9uKSBFbW90aW9uIHdlY2hzZWxuIHVuZCByb3RhdGUtaW4gc3RhcnRlbiAtIGRvcHBlbHQgc28gc2NobmVsbFxuICAgIGVtb3Rpb25DaGFuZ2VUaW1lci5jdXJyZW50ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyhg8J+OrSBNSUQtUk9UQVRJT046IFNldHRpbmcgZW1vdGlvbiB0byAke25ld0Vtb3Rpb259YCk7XG4gICAgICBzZXRDdXJyZW50RW1vdGlvbihuZXdFbW90aW9uKTtcbiAgICAgIHNlbGVjdFZhcmlhbnRGb3JFbW90aW9uKG5ld0Vtb3Rpb24pOyAvLyBOZXVlIFZhcmlhbnRlIHfDpGhsZW5cbiAgICAgIHNldFJvdGF0aW9uUGhhc2UoJ2luJyk7XG4gICAgICBcbiAgICAgIC8vIE5hY2ggd2VpdGVyZW4gMTUwbXMgUm90YXRpb24gdm9sbHN0w6RuZGlnIGJlZW5kZW4gLSBkb3BwZWx0IHNvIHNjaG5lbGxcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBzZXRJc1JvdGF0aW5nKGZhbHNlKTtcbiAgICAgICAgc2V0Um90YXRpb25QaGFzZSgnaWRsZScpO1xuICAgICAgICBjb25zb2xlLmxvZyhg8J+OrSBST1RBVElPTiBDT01QTEVURTogTm93ICR7bmV3RW1vdGlvbn1gKTtcbiAgICAgIH0sIDE1MCk7XG4gICAgfSwgMTUwKTtcbiAgfTtcblxuICAvLyBBdXRvLVJlc2V0IGVudGZlcm50IC0gQ2hhcmFjdGVyIHdlY2hzZWx0IG51ciBiZWkgSW50ZXJha3Rpb25lblxuXG4gIC8vIENvbnRleHQtYWJow6RuZ2lnZSBFbW90aW9uZW4gbGFkZW5cbiAgY29uc3QgbG9hZENvbnRleHRFbW90aW9ucyA9IGFzeW5jIChjb250ZXh0KSA9PiB7XG4gICAgY29uc29sZS5sb2coYPCfjq0gbG9hZENvbnRleHRFbW90aW9ucyBjYWxsZWQgd2l0aCBjb250ZXh0OiAnJHtjb250ZXh0fScgKGxhc3RQcm9jZXNzZWQ6ICcke2xhc3RQcm9jZXNzZWRDb250ZXh0fScpYCk7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvY2hhcmFjdGVyL3JhbmRvbS1lbW90aW9uLyR7Y29udGV4dH1gKTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBcbiAgICAgIGlmIChkYXRhLmVtb3Rpb25zKSB7XG4gICAgICAgIHNldEF2YWlsYWJsZUVtb3Rpb25zKGRhdGEuZW1vdGlvbnMpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ29vbGRvd24gcHLDvGZlbjogS2VpbmUgRW1vdGlvbi1XZWNoc2VsIHdlbm4gZGVyIGxldHp0ZSB2b3Igd2VuaWdlciBhbHMgMiBTZWt1bmRlbiB3YXJcbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgdGltZVNpbmNlTGFzdENoYW5nZSA9IG5vdyAtIGxhc3RFbW90aW9uQ2hhbmdlVGltZTtcbiAgICAgICAgY29uc3QgRU1PVElPTl9DT09MRE9XTiA9IDIwMDA7IC8vIDIgU2VrdW5kZW4gQ29vbGRvd25cbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKGDwn46tIENvbnRleHQgY2hlY2s6IGNvbnRleHQ9JHtjb250ZXh0fSwgbGFzdFByb2Nlc3NlZD0ke2xhc3RQcm9jZXNzZWRDb250ZXh0fSwgY29vbGRvd249JHt0aW1lU2luY2VMYXN0Q2hhbmdlfW1zYCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoY29udGV4dCAhPT0gJ2lkbGUnICYmIGNvbnRleHQgIT09IGxhc3RQcm9jZXNzZWRDb250ZXh0ICYmIHRpbWVTaW5jZUxhc3RDaGFuZ2UgPj0gRU1PVElPTl9DT09MRE9XTikge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn46tIFRSSUdHRVJJTkcgZW1vdGlvbiBjaGFuZ2UgZm9yIGNvbnRleHQgJyR7Y29udGV4dH0nYCk7XG4gICAgICAgICAgY29uc3QgcmFuZG9tRW1vdGlvbiA9IGRhdGEuZW1vdGlvbnNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogZGF0YS5lbW90aW9ucy5sZW5ndGgpXTtcbiAgICAgICAgICBjaGFuZ2VFbW90aW9uKHJhbmRvbUVtb3Rpb24sIGZhbHNlKTtcbiAgICAgICAgICBzZXRMYXN0UHJvY2Vzc2VkQ29udGV4dChjb250ZXh0KTsgLy8gTWVya2UgZGFzcyB3aXIgZGllc2VuIENvbnRleHQgc2Nob24gdmVyYXJiZWl0ZXQgaGFiZW5cbiAgICAgICAgICBzZXRMYXN0RW1vdGlvbkNoYW5nZVRpbWUobm93KTsgLy8gU2V0emUgQ29vbGRvd24tVGltZXJcbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0ID09PSBsYXN0UHJvY2Vzc2VkQ29udGV4dCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn46tIEJMT0NLRUQ6IENvbnRleHQgJyR7Y29udGV4dH0nIGFscmVhZHkgcHJvY2Vzc2VkYCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGltZVNpbmNlTGFzdENoYW5nZSA8IEVNT1RJT05fQ09PTERPV04pIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhg8J+OrSBCTE9DS0VEOiBDb29sZG93biBhY3RpdmUgKCR7dGltZVNpbmNlTGFzdENoYW5nZX1tcyA8ICR7RU1PVElPTl9DT09MRE9XTn1tcylgKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0ID09PSAnaWRsZScpIHtcbiAgICAgICAgICAvLyBCZWkgaWRsZS1Db250ZXh0OiBSZXNldCBsYXN0UHJvY2Vzc2VkQ29udGV4dCBmw7xyIG7DpGNoc3RlIEludGVyYWt0aW9uIChhYmVyIGtlaW4gQ29vbGRvd24gUmVzZXQpXG4gICAgICAgICAgY29uc29sZS5sb2coYPCfjq0gUkVTRVQ6IElkbGUgY29udGV4dCwgY2xlYXJpbmcgbGFzdFByb2Nlc3NlZENvbnRleHRgKTtcbiAgICAgICAgICBzZXRMYXN0UHJvY2Vzc2VkQ29udGV4dChudWxsKTtcbiAgICAgICAgICAvLyBDaGFyYWN0ZXIgd2lyZCBOSUNIVCBuZXUgaW5zdGFuemllcnQsIG51ciBoYXNMb2FkZWQgYmxlaWJ0IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIGNvbnRleHQgZW1vdGlvbnM6JywgZXJyb3IpO1xuICAgICAgc2V0QXZhaWxhYmxlRW1vdGlvbnMoWydpZGxlJywgJ2N1cmlvdXMnXSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFp1ZsOkbGxpZ2VzIExhY2hlbiBhYnNwaWVsZW4gKG9obmUgVm9pY2UtT3ZlcnMgenUgdW50ZXJicmVjaGVuKVxuICBjb25zdCBwbGF5UmFuZG9tTGF1Z2h0ZXIgPSAoKSA9PiB7XG4gICAgY29uc3QgbGF1Z2h0ZXJGaWxlcyA9IFtcbiAgICAgICcvYXVkaW8vTGF1Z2hpbmdLaWQvbGF1Z2hpbmctMS53YXYnLFxuICAgICAgJy9hdWRpby9MYXVnaGluZ0tpZC9sYXVnaGluZy0yLndhdicsXG4gICAgICAnL2F1ZGlvL0xhdWdoaW5nS2lkL2xhdWdoaW5nLTMud2F2JyxcbiAgICAgICcvYXVkaW8vTGF1Z2hpbmdLaWQvbGF1Z2hpbmctNC53YXYnLFxuICAgICAgJy9hdWRpby9MYXVnaGluZ0tpZC9sYXVnaGluZy01LndhdicsXG4gICAgICAnL2F1ZGlvL0xhdWdoaW5nS2lkL2xhdWdoaW5nLTYud2F2JyxcbiAgICAgICcvYXVkaW8vTGF1Z2hpbmdLaWQvbGF1Z2hpbmctNy53YXYnXG4gICAgXTtcbiAgICBcbiAgICAvLyBadWbDpGxsaWdlIExhY2hlci1EYXRlaSBhdXN3w6RobGVuXG4gICAgY29uc3QgcmFuZG9tTGF1Z2h0ZXIgPSBsYXVnaHRlckZpbGVzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGxhdWdodGVyRmlsZXMubGVuZ3RoKV07XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIFNFUEFSQVRFUyBBdWRpby1FbGVtZW50IGbDvHIgTGFjaGVyIChuaWNodCBnbG9iYWwhKVxuICAgICAgY29uc3QgbGF1Z2h0ZXJBdWRpbyA9IG5ldyBBdWRpbyhyYW5kb21MYXVnaHRlcik7XG4gICAgICBsYXVnaHRlckF1ZGlvLnZvbHVtZSA9IDAuNzsgLy8gRXR3YXMgbGVpc2VyIGFscyBWb2ljZS1PdmVyc1xuICAgICAgXG4gICAgICBsYXVnaHRlckF1ZGlvLnBsYXkoKS5jYXRjaChlcnIgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnTGFjaGVyLUF1ZGlvIGF1dG9wbGF5IHZlcmhpbmRlcnQ6JywgZXJyKTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygn8J+koyBMYWNoZXIgYWJnZXNwaWVsdDonLCByYW5kb21MYXVnaHRlcik7XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignTGFjaGVyLUF1ZGlvLUZlaGxlcjonLCBlcnJvcik7XG4gICAgfVxuICB9O1xuXG4gIC8vIENoYXJhY3RlciBhbnRpcHBlbiAtIFJvdGF0aW9uLCBFbW90aW9uLVdlY2hzZWwgVU5EIExhY2hlblxuICBjb25zdCBoYW5kbGVDaGFyYWN0ZXJDbGljayA9ICgpID0+IHtcbiAgICAvLyBadSBsYXVnaGluZyBvZGVyIGV4Y2l0ZWQgd2VjaHNlbG4sIGFiZXIgTklFTUFMUyBkaWUgYWt0dWVsbGUgRW1vdGlvblxuICAgIGNvbnN0IGhhcHB5RW1vdGlvbnMgPSBbJ2xhdWdoaW5nJywgJ2V4Y2l0ZWQnXTtcbiAgICBsZXQgcmFuZG9tSGFwcHlFbW90aW9uO1xuICAgIFxuICAgIC8vIEFuZGVyZSBFbW90aW9uIHfDpGhsZW4gYWxzIGRpZSBha3R1ZWxsZVxuICAgIGlmIChjdXJyZW50RW1vdGlvbiA9PT0gJ2xhdWdoaW5nJykge1xuICAgICAgcmFuZG9tSGFwcHlFbW90aW9uID0gJ2V4Y2l0ZWQnO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudEVtb3Rpb24gPT09ICdleGNpdGVkJykge1xuICAgICAgcmFuZG9tSGFwcHlFbW90aW9uID0gJ2xhdWdoaW5nJzsgIFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZW5uIHdlZGVyIGxhdWdoaW5nIG5vY2ggZXhjaXRlZCwgenVmw6RsbGlnIHfDpGhsZW5cbiAgICAgIHJhbmRvbUhhcHB5RW1vdGlvbiA9IGhhcHB5RW1vdGlvbnNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogaGFwcHlFbW90aW9ucy5sZW5ndGgpXTtcbiAgICB9XG4gICAgXG4gICAgY2hhbmdlRW1vdGlvbihyYW5kb21IYXBweUVtb3Rpb24pO1xuICAgIHNldExhc3RFbW90aW9uQ2hhbmdlVGltZShEYXRlLm5vdygpKTsgLy8gQ29vbGRvd24tVGltZXIgYXVjaCBiZWkgZGlyZWt0ZW0gQ2hhcmFjdGVyLUtsaWNrIHNldHplblxuICAgIFxuICAgIC8vIFp1ZsOkbGxpZ2VzIExhY2hlbiBhYnNwaWVsZW4gKHBhcmFsbGVsIHp1IFZvaWNlLU92ZXJzKVxuICAgIHBsYXlSYW5kb21MYXVnaHRlcigpO1xuICAgIFxuICAgIC8vIENhbGxiYWNrIGbDvHIgRW1vdGlvbi3DhG5kZXJ1bmdcbiAgICBpZiAob25FbW90aW9uQ2hhbmdlKSB7XG4gICAgICBvbkVtb3Rpb25DaGFuZ2UocmFuZG9tSGFwcHlFbW90aW9uKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gSW5pdGlhbCBGbHktSW4gQW5pbWF0aW9uIHN0YXJ0ZW4gLSBOVVIgRUlOTUFMIGJlaW0gZXJzdGVuIE1vdW50XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gTmFjaCBrdXJ6ZXIgVmVyesO2Z2VydW5nIENoYXJhY3RlciByZWluZmxpZWdlbiBsYXNzZW5cbiAgICBjb25zdCBsb2FkVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHNldEhhc0xvYWRlZCh0cnVlKTtcbiAgICB9LCAzMDApO1xuICAgIFxuICAgIHJldHVybiAoKSA9PiBjbGVhclRpbWVvdXQobG9hZFRpbWVyKTtcbiAgfSwgW10pOyAvLyBMZWVyZXMgQXJyYXkgLSBOVVIgYmVpbSBlcnN0ZW4gTW91bnRcbiAgXG4gIC8vIERlYnVnOiBDaGFyYWN0ZXIgTW91bnQvVW5tb3VudCB0cmFja2luZ1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKGDwn46tIENoYXJhY3RlciBNT1VOVEVEL1JFLU1PVU5URURgKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc29sZS5sb2coYPCfjq0gQ2hhcmFjdGVyIFVOTU9VTlRFRGApO1xuICAgIH07XG4gIH0sIFtdKTtcblxuICAvLyBDb250ZXh0LcOEbmRlcnVuZ2VuIMO8YmVyd2FjaGVuIC0gbWl0IFJlZiB1bSBkb3BwZWx0ZSBBdWZydWZlIHp1IHZlcmhpbmRlcm5cbiAgY29uc3QgbGFzdENvbnRleHRSZWYgPSB1c2VSZWYobnVsbCk7XG4gIFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKGDwn46tIHVzZUVmZmVjdCB0cmlnZ2VyZWQ6IGN1cnJlbnRDb250ZXh0PScke2N1cnJlbnRDb250ZXh0fScsIGxhc3RDb250ZXh0UmVmPScke2xhc3RDb250ZXh0UmVmLmN1cnJlbnR9J2ApO1xuICAgIFxuICAgIGlmIChjdXJyZW50Q29udGV4dCAmJiBjdXJyZW50Q29udGV4dCAhPT0gbGFzdENvbnRleHRSZWYuY3VycmVudCkge1xuICAgICAgY29uc29sZS5sb2coYPCfjq0gdXNlRWZmZWN0OiBQcm9jZXNzaW5nIE5FVyBjb250ZXh0ICcke2N1cnJlbnRDb250ZXh0fSdgKTtcbiAgICAgIGxhc3RDb250ZXh0UmVmLmN1cnJlbnQgPSBjdXJyZW50Q29udGV4dDtcbiAgICAgIGxvYWRDb250ZXh0RW1vdGlvbnMoY3VycmVudENvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudENvbnRleHQgPT09IGxhc3RDb250ZXh0UmVmLmN1cnJlbnQpIHtcbiAgICAgIGNvbnNvbGUubG9nKGDwn46tIHVzZUVmZmVjdDogSUdOT1JJTkcgZHVwbGljYXRlIGNvbnRleHQgJyR7Y3VycmVudENvbnRleHR9J2ApO1xuICAgIH1cbiAgfSwgW2N1cnJlbnRDb250ZXh0XSk7XG5cbiAgLy8gQ2xlYW51cCBUaW1lclxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoYXV0b1Jlc2V0VGltZXIuY3VycmVudCkgY2xlYXJUaW1lb3V0KGF1dG9SZXNldFRpbWVyLmN1cnJlbnQpO1xuICAgICAgaWYgKGVtb3Rpb25DaGFuZ2VUaW1lci5jdXJyZW50KSBjbGVhclRpbWVvdXQoZW1vdGlvbkNoYW5nZVRpbWVyLmN1cnJlbnQpO1xuICAgIH07XG4gIH0sIFtdKTtcblxuICAvLyBBbmltYXRpb24tS2xhc3NlbiBiZXN0aW1tZW5cbiAgY29uc3QgZ2V0QW5pbWF0aW9uQ2xhc3NlcyA9ICgpID0+IHtcbiAgICBsZXQgY2xhc3NlcyA9ICdjaGFyYWN0ZXItaW1hZ2UnO1xuICAgIFxuICAgIC8vIEluaXRpYWwgRmx5LUluIEFuaW1hdGlvbiBiZWltIGVyc3RlbiBMYWRlblxuICAgIGlmICghaGFzTG9hZGVkKSB7XG4gICAgICBjbGFzc2VzICs9ICcgY2hhcmFjdGVyLWZseS1pbic7XG4gICAgICByZXR1cm4gY2xhc3NlcztcbiAgICB9XG4gICAgXG4gICAgaWYgKHJvdGF0aW9uUGhhc2UgPT09ICdvdXQnKSB7XG4gICAgICBjbGFzc2VzICs9ICcgY2hhcmFjdGVyLXJvdGF0ZS1vdXQnO1xuICAgIH0gZWxzZSBpZiAocm90YXRpb25QaGFzZSA9PT0gJ2luJykge1xuICAgICAgY2xhc3NlcyArPSAnIGNoYXJhY3Rlci1yb3RhdGUtaW4nO1xuICAgIH1cbiAgICBcbiAgICAvLyBTdWJ0aWxlIExvb3AtQW5pbWF0aW9uIHdlbm4ga2VpbmUgUm90YXRpb24gbMOkdWZ0XG4gICAgaWYgKHJvdGF0aW9uUGhhc2UgPT09ICdpZGxlJykge1xuICAgICAgY2xhc3NlcyArPSAnIGNoYXJhY3Rlci1zdWJ0bGUtYW5pbWF0aW9uJztcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGNsYXNzZXM7XG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IFxuICAgICAgY2xhc3NOYW1lPVwiY2hhcmFjdGVyLWNvbnRhaW5lclwiXG4gICAgICBvbkNsaWNrPXtoYW5kbGVDaGFyYWN0ZXJDbGlja31cbiAgICAgIHRpdGxlPVwiQ2hhcmFjdGVyIGFudGlwcGVuIGbDvHIgRW1vdGlvbmVuIVwiXG4gICAgPlxuICAgICAgPEltYWdlXG4gICAgICAgIHNyYz17c2VsZWN0ZWRWYXJpYW50fVxuICAgICAgICBhbHQ9e2BDaGFyYWN0ZXIgJHtjdXJyZW50RW1vdGlvbn1gfVxuICAgICAgICB3aWR0aD17MTIwfVxuICAgICAgICBoZWlnaHQ9ezE1MH1cbiAgICAgICAgY2xhc3NOYW1lPXtnZXRBbmltYXRpb25DbGFzc2VzKCl9XG4gICAgICAgIHByaW9yaXR5XG4gICAgICAgIHVub3B0aW1pemVkIC8vIEbDvHIgbG9rYWxlIEVudHdpY2tsdW5nXG4gICAgICAvPlxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQ2hhcmFjdGVyOyBcbi8vIENhY2hlLVJlZnJlc2g6IFVwZGF0ZWQgQ2hhcmFjdGVyIEFuaW1hdGlvbiBhbmQgcmVtb3ZlZCBpc0JvdW5jaW5nICJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZVJlZiIsIkltYWdlIiwiQ2hhcmFjdGVyIiwiY3VycmVudENvbnRleHQiLCJvbkVtb3Rpb25DaGFuZ2UiLCJjdXJyZW50RW1vdGlvbiIsInNldEN1cnJlbnRFbW90aW9uIiwiaXNSb3RhdGluZyIsInNldElzUm90YXRpbmciLCJyb3RhdGlvblBoYXNlIiwic2V0Um90YXRpb25QaGFzZSIsImF2YWlsYWJsZUVtb3Rpb25zIiwic2V0QXZhaWxhYmxlRW1vdGlvbnMiLCJoYXNMb2FkZWQiLCJzZXRIYXNMb2FkZWQiLCJsYXN0UHJvY2Vzc2VkQ29udGV4dCIsInNldExhc3RQcm9jZXNzZWRDb250ZXh0IiwibGFzdEVtb3Rpb25DaGFuZ2VUaW1lIiwic2V0TGFzdEVtb3Rpb25DaGFuZ2VUaW1lIiwiYXV0b1Jlc2V0VGltZXIiLCJlbW90aW9uQ2hhbmdlVGltZXIiLCJjaGFyYWN0ZXJWYXJpYW50cyIsImlkbGUiLCJleGNpdGVkIiwiY3VyaW91cyIsInN1cnByaXNlZCIsInRoaW5raW5nIiwibGF1Z2hpbmciLCJleHBsb3JpbmciLCJzY2FyZWQiLCJzZWxlY3RlZFZhcmlhbnQiLCJzZXRTZWxlY3RlZFZhcmlhbnQiLCJzZWxlY3RWYXJpYW50Rm9yRW1vdGlvbiIsImVtb3Rpb24iLCJ2YXJpYW50cyIsImxlbmd0aCIsInZhcmlhbnQiLCJvdGhlclZhcmlhbnRzIiwiZmlsdGVyIiwicmFuZG9tVmFyaWFudCIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsImdldFJhbmRvbUVtb3Rpb24iLCJlbW90aW9ucyIsImZpbHRlcmVkIiwiZSIsImNoYW5nZUVtb3Rpb24iLCJuZXdFbW90aW9uIiwiaW1tZWRpYXRlIiwiY29uc29sZSIsImxvZyIsImN1cnJlbnQiLCJzZXRUaW1lb3V0IiwibG9hZENvbnRleHRFbW90aW9ucyIsImNvbnRleHQiLCJyZXNwb25zZSIsImZldGNoIiwiZGF0YSIsImpzb24iLCJub3ciLCJEYXRlIiwidGltZVNpbmNlTGFzdENoYW5nZSIsIkVNT1RJT05fQ09PTERPV04iLCJyYW5kb21FbW90aW9uIiwiZXJyb3IiLCJwbGF5UmFuZG9tTGF1Z2h0ZXIiLCJsYXVnaHRlckZpbGVzIiwicmFuZG9tTGF1Z2h0ZXIiLCJsYXVnaHRlckF1ZGlvIiwiQXVkaW8iLCJ2b2x1bWUiLCJwbGF5IiwiY2F0Y2giLCJlcnIiLCJoYW5kbGVDaGFyYWN0ZXJDbGljayIsImhhcHB5RW1vdGlvbnMiLCJyYW5kb21IYXBweUVtb3Rpb24iLCJsb2FkVGltZXIiLCJjbGVhclRpbWVvdXQiLCJsYXN0Q29udGV4dFJlZiIsImdldEFuaW1hdGlvbkNsYXNzZXMiLCJjbGFzc2VzIiwiZGl2IiwiY2xhc3NOYW1lIiwib25DbGljayIsInRpdGxlIiwic3JjIiwiYWx0Iiwid2lkdGgiLCJoZWlnaHQiLCJwcmlvcml0eSIsInVub3B0aW1pemVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./components/Character.js\n"));

/***/ })

});