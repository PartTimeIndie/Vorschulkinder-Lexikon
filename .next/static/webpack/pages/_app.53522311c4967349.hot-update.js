"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./utils/assetCache.js":
/*!*****************************!*\
  !*** ./utils/assetCache.js ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clearAllAssetCache: function() { return /* binding */ clearAllAssetCache; },\n/* harmony export */   clearAllCachesDeep: function() { return /* binding */ clearAllCachesDeep; },\n/* harmony export */   clearCachedAsset: function() { return /* binding */ clearCachedAsset; },\n/* harmony export */   extractAllReferencedAssetUrls: function() { return /* binding */ extractAllReferencedAssetUrls; },\n/* harmony export */   getCachedAsset: function() { return /* binding */ getCachedAsset; },\n/* harmony export */   getCachedAssetAsBlob: function() { return /* binding */ getCachedAssetAsBlob; },\n/* harmony export */   getCachedAudioAsBlob: function() { return /* binding */ getCachedAudioAsBlob; },\n/* harmony export */   getCachedJson: function() { return /* binding */ getCachedJson; },\n/* harmony export */   getOfflineAssetFileList: function() { return /* binding */ getOfflineAssetFileList; }\n/* harmony export */ });\n/* harmony import */ var idb_keyval__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! idb-keyval */ \"./node_modules/idb-keyval/dist/index.js\");\n\nfunction getCacheKey(url) {\n    let version = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\";\n    return \"assetcache_\".concat(url, \"_\").concat(version);\n}\n/**\r\n * Fetches an asset (image, audio, etc.) from cache or downloads and stores it as a Base64 string.\r\n * @param {string} url - The asset URL.\r\n * @param {string} version - Optional version string for cache busting.\r\n * @returns {Promise<string>} - Base64 string of the asset.\r\n */ async function getCachedAsset(url) {\n    let version = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\";\n    if (!url || url === \"null\" || url === \"/null\") return null;\n    const cacheKey = getCacheKey(url, version);\n    try {\n        const cached = await (0,idb_keyval__WEBPACK_IMPORTED_MODULE_0__.get)(cacheKey);\n        if (cached) return cached;\n    } catch (e) {\n        console.warn(\"AssetCache: IndexedDB not available\", e);\n    }\n    // Fetch and cache asset as Base64\n    const response = await fetch(url);\n    if (!response.ok) throw new Error(\"Asset download failed: \" + url);\n    const blob = await response.blob();\n    const base64 = await new Promise((resolve, reject)=>{\n        const reader = new FileReader();\n        reader.onloadend = ()=>resolve(reader.result);\n        reader.onerror = reject;\n        reader.readAsDataURL(blob);\n    });\n    try {\n        await (0,idb_keyval__WEBPACK_IMPORTED_MODULE_0__.set)(cacheKey, base64);\n    } catch (e) {\n        console.warn(\"AssetCache: IndexedDB full or error, cannot cache asset\", e);\n    }\n    return base64;\n}\n/**\r\n * Removes a cached asset from IndexedDB.\r\n * @param {string} url - The asset URL.\r\n * @param {string} version - Optional version string for cache busting.\r\n */ async function clearCachedAsset(url) {\n    let version = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\";\n    const cacheKey = getCacheKey(url, version);\n    await (0,idb_keyval__WEBPACK_IMPORTED_MODULE_0__.del)(cacheKey);\n}\n/**\r\n * Fetches a JSON file from cache or downloads and stores it as a string.\r\n * @param {string} url - The JSON URL.\r\n * @param {string} version - Optional version string for cache busting.\r\n * @returns {Promise<any>} - Parsed JSON object.\r\n */ async function getCachedJson(url) {\n    let version = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\";\n    // Cache-Busting für zentrale JSONs\n    if ( true && (url.includes(\"/kategorien/tiere.json\") || url.includes(\"/eintraege/tierEintraege.json\"))) {\n        const sep = url.includes(\"?\") ? \"&\" : \"?\";\n        url = url + sep + \"v=\" + Date.now();\n    }\n    const cacheKey = getCacheKey(url, version) + \"_json\";\n    try {\n        const cached = await (0,idb_keyval__WEBPACK_IMPORTED_MODULE_0__.get)(cacheKey);\n        if (cached) return JSON.parse(cached);\n    } catch (e) {\n        console.warn(\"AssetCache: IndexedDB not available\", e);\n    }\n    // Fetch and cache JSON as text\n    const response = await fetch(url);\n    if (!response.ok) throw new Error(\"JSON download failed: \" + url);\n    const text = await response.text();\n    try {\n        await (0,idb_keyval__WEBPACK_IMPORTED_MODULE_0__.set)(cacheKey, text);\n    } catch (e) {\n        console.warn(\"AssetCache: IndexedDB full or error, cannot cache JSON\", e);\n    }\n    return JSON.parse(text);\n}\n/**\r\n * Holt ein Asset als Blob aus dem Cache oder lädt es per fetch und speichert es als Base64 im Cache.\r\n * @param {string} url - Die Asset-URL.\r\n * @param {string} version - Optionaler Versionsstring für Cache Busting.\r\n * @returns {Promise<Blob|null>} - Das Asset als Blob oder null.\r\n */ async function getCachedAssetAsBlob(url) {\n    let version = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\";\n    if (!url || url === \"null\" || url === \"/null\") return null;\n    const cacheKey = getCacheKey(url, version);\n    try {\n        const cached = await (0,idb_keyval__WEBPACK_IMPORTED_MODULE_0__.get)(cacheKey);\n        if (cached) {\n            // cached ist ein Base64-String → in Blob umwandeln\n            const base64 = cached.split(\",\")[1];\n            const mimeString = cached.split(\",\")[0].split(\":\")[1].split(\";\")[0];\n            const byteString = atob(base64);\n            const ab = new ArrayBuffer(byteString.length);\n            const ia = new Uint8Array(ab);\n            for(let i = 0; i < byteString.length; i++){\n                ia[i] = byteString.charCodeAt(i);\n            }\n            return new Blob([\n                ab\n            ], {\n                type: mimeString\n            });\n        }\n    } catch (e) {\n    // IndexedDB nicht verfügbar oder Fehler\n    }\n    // Fallback: fetch und als Blob speichern\n    const response = await fetch(url);\n    if (!response.ok) throw new Error(\"Asset download failed: \" + url);\n    const blob = await response.blob();\n    // Optional: als Base64 im Cache speichern (wie getCachedAsset)\n    const reader = new FileReader();\n    const base64 = await new Promise((resolve, reject)=>{\n        reader.onloadend = ()=>resolve(reader.result);\n        reader.onerror = reject;\n        reader.readAsDataURL(blob);\n    });\n    try {\n        await (0,idb_keyval__WEBPACK_IMPORTED_MODULE_0__.set)(cacheKey, base64);\n    } catch (e) {}\n    return blob;\n}\n/**\r\n * Holt eine Audio-Datei als Blob aus dem Cache oder lädt sie per fetch und speichert sie als Base64 im Cache.\r\n * @param {string} url - Die Audio-URL.\r\n * @param {string} version - Optionaler Versionsstring für Cache Busting.\r\n * @returns {Promise<Blob|null>} - Die Audio-Datei als Blob oder null.\r\n */ async function getCachedAudioAsBlob(url) {\n    let version = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\";\n    if (!url || url === \"null\" || url === \"/null\") return null;\n    const cacheKey = getCacheKey(url, version);\n    try {\n        const cached = await (0,idb_keyval__WEBPACK_IMPORTED_MODULE_0__.get)(cacheKey);\n        if (cached) {\n            // cached ist ein Base64-String → in Blob umwandeln\n            const base64 = cached.split(\",\")[1];\n            const mimeString = cached.split(\",\")[0].split(\":\")[1].split(\";\")[0];\n            const byteString = atob(base64);\n            const ab = new ArrayBuffer(byteString.length);\n            const ia = new Uint8Array(ab);\n            for(let i = 0; i < byteString.length; i++){\n                ia[i] = byteString.charCodeAt(i);\n            }\n            return new Blob([\n                ab\n            ], {\n                type: mimeString\n            });\n        }\n    } catch (e) {\n    // IndexedDB nicht verfügbar oder Fehler\n    }\n    // Fallback: fetch und als Blob speichern\n    const response = await fetch(url);\n    if (!response.ok) throw new Error(\"Audio download failed: \" + url);\n    const blob = await response.blob();\n    // Optional: als Base64 im Cache speichern (wie getCachedAsset)\n    const reader = new FileReader();\n    const base64 = await new Promise((resolve, reject)=>{\n        reader.onloadend = ()=>resolve(reader.result);\n        reader.onerror = reject;\n        reader.readAsDataURL(blob);\n    });\n    try {\n        await (0,idb_keyval__WEBPACK_IMPORTED_MODULE_0__.set)(cacheKey, base64);\n    } catch (e) {}\n    return blob;\n}\n/**\r\n * Extracts all referenced image and audio asset URLs from category and animal data.\r\n * @param {object} categoryData - The main category JSON (with subcategories).\r\n * @param {object} animalData - The animal entries JSON (with tiere array).\r\n * @returns {string[]} Array of asset URLs (relative to public/)\r\n */ function extractAllReferencedAssetUrls(categoryData, animalData) {\n    const urls = new Set();\n    // Main category image/audio\n    if (categoryData.image && categoryData.image.path) urls.add(categoryData.image.path);\n    if (categoryData.audio && categoryData.audio.path) urls.add(categoryData.audio.path);\n    // Subcategories\n    if (Array.isArray(categoryData.subcategories)) {\n        for (const sub of categoryData.subcategories){\n            if (sub.image && sub.image.path) urls.add(sub.image.path);\n            if (sub.audio && sub.audio.path) urls.add(sub.audio.path);\n        }\n    }\n    // Animals\n    if (animalData && Array.isArray(animalData.tiere)) {\n        for (const animal of animalData.tiere){\n            if (animal.image && animal.image.path) urls.add(animal.image.path);\n            if (animal.audio && animal.audio.path) urls.add(animal.audio.path);\n        }\n    }\n    // Return as array, prefix with '/' for fetch\n    return Array.from(urls).map((path)=>path.startsWith(\"/\") ? path : \"/\" + path);\n}\n/**\r\n * Fetches the list of all files to be downloaded for offline use.\r\n * @returns {Promise<string[]>} Array of asset URLs (relative to public/)\r\n */ async function getOfflineAssetFileList() {\n    const res = await fetch(\"/offlineAssetFileList.json\");\n    if (!res.ok) throw new Error(\"Failed to fetch offline asset file list\");\n    return await res.json();\n}\n/**\r\n * Löscht alle gecachten Assets (Bilder, MP3s etc.) aus IndexedDB.\r\n * Wird z.B. bei Versionswechsel aufgerufen.\r\n */ async function clearAllAssetCache() {\n    const allKeys = await (0,idb_keyval__WEBPACK_IMPORTED_MODULE_0__.keys)();\n    const assetKeys = allKeys.filter((key)=>typeof key === \"string\" && key.startsWith(\"assetcache_\"));\n    for (const key of assetKeys){\n        await (0,idb_keyval__WEBPACK_IMPORTED_MODULE_0__.del)(key);\n    }\n}\n/**\r\n * Löscht wirklich alle Caches: IndexedDB, LocalStorage, Caches API, Service Worker.\r\n */ async function clearAllCachesDeep() {\n    // 1. IndexedDB (wie bisher)\n    await clearAllAssetCache();\n    // 2. LocalStorage (nur relevante Keys, nicht alles!)\n    if (true) {\n        Object.keys(localStorage).forEach((key)=>{\n            if (key.startsWith(\"imgcache_\") || key.startsWith(\"klex_\") || key.startsWith(\"kinderlexikon_\")) {\n                localStorage.removeItem(key);\n            }\n        });\n    }\n    // 3. Caches API (Service Worker Cache)\n    if (\"caches\" in window) {\n        const cacheNames = await caches.keys();\n        for (const name of cacheNames){\n            await caches.delete(name);\n        }\n    }\n    // 4. Service Worker deregistrieren (optional, wird beim Reload neu registriert)\n    if (\"serviceWorker\" in navigator) {\n        const regs = await navigator.serviceWorker.getRegistrations();\n        for (const reg of regs){\n            await reg.unregister();\n        }\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SUFDdkMsSUFBSSxZQUFZTSxRQUFRO1FBQ3RCLE1BQU1DLGFBQWEsTUFBTUMsT0FBT2xGLElBQUk7UUFDcEMsS0FBSyxNQUFNbUYsUUFBUUYsV0FBWTtZQUM3QixNQUFNQyxPQUFPRSxNQUFNLENBQUNEO1FBQ3RCO0lBQ0Y7SUFFQSxnRkFBZ0Y7SUFDaEYsSUFBSSxtQkFBbUJFLFdBQVc7UUFDaEMsTUFBTUMsT0FBTyxNQUFNRCxVQUFVRSxhQUFhLENBQUNDLGdCQUFnQjtRQUMzRCxLQUFLLE1BQU1DLE9BQU9ILEtBQU07WUFDdEIsTUFBTUcsSUFBSUMsVUFBVTtRQUN0QjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vdXRpbHMvYXNzZXRDYWNoZS5qcz84YWE0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHNldCwgZ2V0LCBkZWwsIGtleXMgfSBmcm9tICdpZGIta2V5dmFsJztcclxuXHJcbmZ1bmN0aW9uIGdldENhY2hlS2V5KHVybCwgdmVyc2lvbiA9ICcnKSB7XHJcbiAgcmV0dXJuIGBhc3NldGNhY2hlXyR7dXJsfV8ke3ZlcnNpb259YDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEZldGNoZXMgYW4gYXNzZXQgKGltYWdlLCBhdWRpbywgZXRjLikgZnJvbSBjYWNoZSBvciBkb3dubG9hZHMgYW5kIHN0b3JlcyBpdCBhcyBhIEJhc2U2NCBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBUaGUgYXNzZXQgVVJMLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdmVyc2lvbiAtIE9wdGlvbmFsIHZlcnNpb24gc3RyaW5nIGZvciBjYWNoZSBidXN0aW5nLlxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSAtIEJhc2U2NCBzdHJpbmcgb2YgdGhlIGFzc2V0LlxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENhY2hlZEFzc2V0KHVybCwgdmVyc2lvbiA9ICcnKSB7XHJcbiAgaWYgKCF1cmwgfHwgdXJsID09PSAnbnVsbCcgfHwgdXJsID09PSAnL251bGwnKSByZXR1cm4gbnVsbDtcclxuICBjb25zdCBjYWNoZUtleSA9IGdldENhY2hlS2V5KHVybCwgdmVyc2lvbik7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGNhY2hlZCA9IGF3YWl0IGdldChjYWNoZUtleSk7XHJcbiAgICBpZiAoY2FjaGVkKSByZXR1cm4gY2FjaGVkO1xyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIGNvbnNvbGUud2FybignQXNzZXRDYWNoZTogSW5kZXhlZERCIG5vdCBhdmFpbGFibGUnLCBlKTtcclxuICB9XHJcblxyXG4gIC8vIEZldGNoIGFuZCBjYWNoZSBhc3NldCBhcyBCYXNlNjRcclxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCk7XHJcbiAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKCdBc3NldCBkb3dubG9hZCBmYWlsZWQ6ICcgKyB1cmwpO1xyXG4gIGNvbnN0IGJsb2IgPSBhd2FpdCByZXNwb25zZS5ibG9iKCk7XHJcbiAgY29uc3QgYmFzZTY0ID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcclxuICAgIHJlYWRlci5vbmxvYWRlbmQgPSAoKSA9PiByZXNvbHZlKHJlYWRlci5yZXN1bHQpO1xyXG4gICAgcmVhZGVyLm9uZXJyb3IgPSByZWplY3Q7XHJcbiAgICByZWFkZXIucmVhZEFzRGF0YVVSTChibG9iKTtcclxuICB9KTtcclxuXHJcbiAgdHJ5IHtcclxuICAgIGF3YWl0IHNldChjYWNoZUtleSwgYmFzZTY0KTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICBjb25zb2xlLndhcm4oJ0Fzc2V0Q2FjaGU6IEluZGV4ZWREQiBmdWxsIG9yIGVycm9yLCBjYW5ub3QgY2FjaGUgYXNzZXQnLCBlKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBiYXNlNjQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZW1vdmVzIGEgY2FjaGVkIGFzc2V0IGZyb20gSW5kZXhlZERCLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gVGhlIGFzc2V0IFVSTC5cclxuICogQHBhcmFtIHtzdHJpbmd9IHZlcnNpb24gLSBPcHRpb25hbCB2ZXJzaW9uIHN0cmluZyBmb3IgY2FjaGUgYnVzdGluZy5cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjbGVhckNhY2hlZEFzc2V0KHVybCwgdmVyc2lvbiA9ICcnKSB7XHJcbiAgY29uc3QgY2FjaGVLZXkgPSBnZXRDYWNoZUtleSh1cmwsIHZlcnNpb24pO1xyXG4gIGF3YWl0IGRlbChjYWNoZUtleSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGZXRjaGVzIGEgSlNPTiBmaWxlIGZyb20gY2FjaGUgb3IgZG93bmxvYWRzIGFuZCBzdG9yZXMgaXQgYXMgYSBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBUaGUgSlNPTiBVUkwuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB2ZXJzaW9uIC0gT3B0aW9uYWwgdmVyc2lvbiBzdHJpbmcgZm9yIGNhY2hlIGJ1c3RpbmcuXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IC0gUGFyc2VkIEpTT04gb2JqZWN0LlxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENhY2hlZEpzb24odXJsLCB2ZXJzaW9uID0gJycpIHtcclxuICAvLyBDYWNoZS1CdXN0aW5nIGbDvHIgemVudHJhbGUgSlNPTnNcclxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgKHVybC5pbmNsdWRlcygnL2thdGVnb3JpZW4vdGllcmUuanNvbicpIHx8IHVybC5pbmNsdWRlcygnL2VpbnRyYWVnZS90aWVyRWludHJhZWdlLmpzb24nKSkpIHtcclxuICAgIGNvbnN0IHNlcCA9IHVybC5pbmNsdWRlcygnPycpID8gJyYnIDogJz8nO1xyXG4gICAgdXJsID0gdXJsICsgc2VwICsgJ3Y9JyArIERhdGUubm93KCk7XHJcbiAgfVxyXG4gIGNvbnN0IGNhY2hlS2V5ID0gZ2V0Q2FjaGVLZXkodXJsLCB2ZXJzaW9uKSArICdfanNvbic7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGNhY2hlZCA9IGF3YWl0IGdldChjYWNoZUtleSk7XHJcbiAgICBpZiAoY2FjaGVkKSByZXR1cm4gSlNPTi5wYXJzZShjYWNoZWQpO1xyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIGNvbnNvbGUud2FybignQXNzZXRDYWNoZTogSW5kZXhlZERCIG5vdCBhdmFpbGFibGUnLCBlKTtcclxuICB9XHJcblxyXG4gIC8vIEZldGNoIGFuZCBjYWNoZSBKU09OIGFzIHRleHRcclxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCk7XHJcbiAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKCdKU09OIGRvd25sb2FkIGZhaWxlZDogJyArIHVybCk7XHJcbiAgY29uc3QgdGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcclxuXHJcbiAgdHJ5IHtcclxuICAgIGF3YWl0IHNldChjYWNoZUtleSwgdGV4dCk7XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgY29uc29sZS53YXJuKCdBc3NldENhY2hlOiBJbmRleGVkREIgZnVsbCBvciBlcnJvciwgY2Fubm90IGNhY2hlIEpTT04nLCBlKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBKU09OLnBhcnNlKHRleHQpO1xyXG59XHJcblxyXG4vKipcclxuICogSG9sdCBlaW4gQXNzZXQgYWxzIEJsb2IgYXVzIGRlbSBDYWNoZSBvZGVyIGzDpGR0IGVzIHBlciBmZXRjaCB1bmQgc3BlaWNoZXJ0IGVzIGFscyBCYXNlNjQgaW0gQ2FjaGUuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBEaWUgQXNzZXQtVVJMLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdmVyc2lvbiAtIE9wdGlvbmFsZXIgVmVyc2lvbnNzdHJpbmcgZsO8ciBDYWNoZSBCdXN0aW5nLlxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxCbG9ifG51bGw+fSAtIERhcyBBc3NldCBhbHMgQmxvYiBvZGVyIG51bGwuXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q2FjaGVkQXNzZXRBc0Jsb2IodXJsLCB2ZXJzaW9uID0gJycpIHtcclxuICBpZiAoIXVybCB8fCB1cmwgPT09ICdudWxsJyB8fCB1cmwgPT09ICcvbnVsbCcpIHJldHVybiBudWxsO1xyXG4gIGNvbnN0IGNhY2hlS2V5ID0gZ2V0Q2FjaGVLZXkodXJsLCB2ZXJzaW9uKTtcclxuICB0cnkge1xyXG4gICAgY29uc3QgY2FjaGVkID0gYXdhaXQgZ2V0KGNhY2hlS2V5KTtcclxuICAgIGlmIChjYWNoZWQpIHtcclxuICAgICAgLy8gY2FjaGVkIGlzdCBlaW4gQmFzZTY0LVN0cmluZyDihpIgaW4gQmxvYiB1bXdhbmRlbG5cclxuICAgICAgY29uc3QgYmFzZTY0ID0gY2FjaGVkLnNwbGl0KCcsJylbMV07XHJcbiAgICAgIGNvbnN0IG1pbWVTdHJpbmcgPSBjYWNoZWQuc3BsaXQoJywnKVswXS5zcGxpdCgnOicpWzFdLnNwbGl0KCc7JylbMF07XHJcbiAgICAgIGNvbnN0IGJ5dGVTdHJpbmcgPSBhdG9iKGJhc2U2NCk7XHJcbiAgICAgIGNvbnN0IGFiID0gbmV3IEFycmF5QnVmZmVyKGJ5dGVTdHJpbmcubGVuZ3RoKTtcclxuICAgICAgY29uc3QgaWEgPSBuZXcgVWludDhBcnJheShhYik7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZVN0cmluZy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlhW2ldID0gYnl0ZVN0cmluZy5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBuZXcgQmxvYihbYWJdLCB7IHR5cGU6IG1pbWVTdHJpbmcgfSk7XHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgLy8gSW5kZXhlZERCIG5pY2h0IHZlcmbDvGdiYXIgb2RlciBGZWhsZXJcclxuICB9XHJcbiAgLy8gRmFsbGJhY2s6IGZldGNoIHVuZCBhbHMgQmxvYiBzcGVpY2hlcm5cclxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCk7XHJcbiAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKCdBc3NldCBkb3dubG9hZCBmYWlsZWQ6ICcgKyB1cmwpO1xyXG4gIGNvbnN0IGJsb2IgPSBhd2FpdCByZXNwb25zZS5ibG9iKCk7XHJcbiAgLy8gT3B0aW9uYWw6IGFscyBCYXNlNjQgaW0gQ2FjaGUgc3BlaWNoZXJuICh3aWUgZ2V0Q2FjaGVkQXNzZXQpXHJcbiAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcclxuICBjb25zdCBiYXNlNjQgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICByZWFkZXIub25sb2FkZW5kID0gKCkgPT4gcmVzb2x2ZShyZWFkZXIucmVzdWx0KTtcclxuICAgIHJlYWRlci5vbmVycm9yID0gcmVqZWN0O1xyXG4gICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoYmxvYik7XHJcbiAgfSk7XHJcbiAgdHJ5IHtcclxuICAgIGF3YWl0IHNldChjYWNoZUtleSwgYmFzZTY0KTtcclxuICB9IGNhdGNoIChlKSB7fVxyXG4gIHJldHVybiBibG9iO1xyXG59XHJcblxyXG4vKipcclxuICogSG9sdCBlaW5lIEF1ZGlvLURhdGVpIGFscyBCbG9iIGF1cyBkZW0gQ2FjaGUgb2RlciBsw6RkdCBzaWUgcGVyIGZldGNoIHVuZCBzcGVpY2hlcnQgc2llIGFscyBCYXNlNjQgaW0gQ2FjaGUuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBEaWUgQXVkaW8tVVJMLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdmVyc2lvbiAtIE9wdGlvbmFsZXIgVmVyc2lvbnNzdHJpbmcgZsO8ciBDYWNoZSBCdXN0aW5nLlxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxCbG9ifG51bGw+fSAtIERpZSBBdWRpby1EYXRlaSBhbHMgQmxvYiBvZGVyIG51bGwuXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q2FjaGVkQXVkaW9Bc0Jsb2IodXJsLCB2ZXJzaW9uID0gJycpIHtcclxuICBpZiAoIXVybCB8fCB1cmwgPT09ICdudWxsJyB8fCB1cmwgPT09ICcvbnVsbCcpIHJldHVybiBudWxsO1xyXG4gIGNvbnN0IGNhY2hlS2V5ID0gZ2V0Q2FjaGVLZXkodXJsLCB2ZXJzaW9uKTtcclxuICB0cnkge1xyXG4gICAgY29uc3QgY2FjaGVkID0gYXdhaXQgZ2V0KGNhY2hlS2V5KTtcclxuICAgIGlmIChjYWNoZWQpIHtcclxuICAgICAgLy8gY2FjaGVkIGlzdCBlaW4gQmFzZTY0LVN0cmluZyDihpIgaW4gQmxvYiB1bXdhbmRlbG5cclxuICAgICAgY29uc3QgYmFzZTY0ID0gY2FjaGVkLnNwbGl0KCcsJylbMV07XHJcbiAgICAgIGNvbnN0IG1pbWVTdHJpbmcgPSBjYWNoZWQuc3BsaXQoJywnKVswXS5zcGxpdCgnOicpWzFdLnNwbGl0KCc7JylbMF07XHJcbiAgICAgIGNvbnN0IGJ5dGVTdHJpbmcgPSBhdG9iKGJhc2U2NCk7XHJcbiAgICAgIGNvbnN0IGFiID0gbmV3IEFycmF5QnVmZmVyKGJ5dGVTdHJpbmcubGVuZ3RoKTtcclxuICAgICAgY29uc3QgaWEgPSBuZXcgVWludDhBcnJheShhYik7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZVN0cmluZy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlhW2ldID0gYnl0ZVN0cmluZy5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBuZXcgQmxvYihbYWJdLCB7IHR5cGU6IG1pbWVTdHJpbmcgfSk7XHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgLy8gSW5kZXhlZERCIG5pY2h0IHZlcmbDvGdiYXIgb2RlciBGZWhsZXJcclxuICB9XHJcbiAgLy8gRmFsbGJhY2s6IGZldGNoIHVuZCBhbHMgQmxvYiBzcGVpY2hlcm5cclxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCk7XHJcbiAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKCdBdWRpbyBkb3dubG9hZCBmYWlsZWQ6ICcgKyB1cmwpO1xyXG4gIGNvbnN0IGJsb2IgPSBhd2FpdCByZXNwb25zZS5ibG9iKCk7XHJcbiAgLy8gT3B0aW9uYWw6IGFscyBCYXNlNjQgaW0gQ2FjaGUgc3BlaWNoZXJuICh3aWUgZ2V0Q2FjaGVkQXNzZXQpXHJcbiAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcclxuICBjb25zdCBiYXNlNjQgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICByZWFkZXIub25sb2FkZW5kID0gKCkgPT4gcmVzb2x2ZShyZWFkZXIucmVzdWx0KTtcclxuICAgIHJlYWRlci5vbmVycm9yID0gcmVqZWN0O1xyXG4gICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoYmxvYik7XHJcbiAgfSk7XHJcbiAgdHJ5IHtcclxuICAgIGF3YWl0IHNldChjYWNoZUtleSwgYmFzZTY0KTtcclxuICB9IGNhdGNoIChlKSB7fVxyXG4gIHJldHVybiBibG9iO1xyXG59XHJcblxyXG4vKipcclxuICogRXh0cmFjdHMgYWxsIHJlZmVyZW5jZWQgaW1hZ2UgYW5kIGF1ZGlvIGFzc2V0IFVSTHMgZnJvbSBjYXRlZ29yeSBhbmQgYW5pbWFsIGRhdGEuXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBjYXRlZ29yeURhdGEgLSBUaGUgbWFpbiBjYXRlZ29yeSBKU09OICh3aXRoIHN1YmNhdGVnb3JpZXMpLlxyXG4gKiBAcGFyYW0ge29iamVjdH0gYW5pbWFsRGF0YSAtIFRoZSBhbmltYWwgZW50cmllcyBKU09OICh3aXRoIHRpZXJlIGFycmF5KS5cclxuICogQHJldHVybnMge3N0cmluZ1tdfSBBcnJheSBvZiBhc3NldCBVUkxzIChyZWxhdGl2ZSB0byBwdWJsaWMvKVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RBbGxSZWZlcmVuY2VkQXNzZXRVcmxzKGNhdGVnb3J5RGF0YSwgYW5pbWFsRGF0YSkge1xyXG4gIGNvbnN0IHVybHMgPSBuZXcgU2V0KCk7XHJcblxyXG4gIC8vIE1haW4gY2F0ZWdvcnkgaW1hZ2UvYXVkaW9cclxuICBpZiAoY2F0ZWdvcnlEYXRhLmltYWdlICYmIGNhdGVnb3J5RGF0YS5pbWFnZS5wYXRoKSB1cmxzLmFkZChjYXRlZ29yeURhdGEuaW1hZ2UucGF0aCk7XHJcbiAgaWYgKGNhdGVnb3J5RGF0YS5hdWRpbyAmJiBjYXRlZ29yeURhdGEuYXVkaW8ucGF0aCkgdXJscy5hZGQoY2F0ZWdvcnlEYXRhLmF1ZGlvLnBhdGgpO1xyXG5cclxuICAvLyBTdWJjYXRlZ29yaWVzXHJcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2F0ZWdvcnlEYXRhLnN1YmNhdGVnb3JpZXMpKSB7XHJcbiAgICBmb3IgKGNvbnN0IHN1YiBvZiBjYXRlZ29yeURhdGEuc3ViY2F0ZWdvcmllcykge1xyXG4gICAgICBpZiAoc3ViLmltYWdlICYmIHN1Yi5pbWFnZS5wYXRoKSB1cmxzLmFkZChzdWIuaW1hZ2UucGF0aCk7XHJcbiAgICAgIGlmIChzdWIuYXVkaW8gJiYgc3ViLmF1ZGlvLnBhdGgpIHVybHMuYWRkKHN1Yi5hdWRpby5wYXRoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEFuaW1hbHNcclxuICBpZiAoYW5pbWFsRGF0YSAmJiBBcnJheS5pc0FycmF5KGFuaW1hbERhdGEudGllcmUpKSB7XHJcbiAgICBmb3IgKGNvbnN0IGFuaW1hbCBvZiBhbmltYWxEYXRhLnRpZXJlKSB7XHJcbiAgICAgIGlmIChhbmltYWwuaW1hZ2UgJiYgYW5pbWFsLmltYWdlLnBhdGgpIHVybHMuYWRkKGFuaW1hbC5pbWFnZS5wYXRoKTtcclxuICAgICAgaWYgKGFuaW1hbC5hdWRpbyAmJiBhbmltYWwuYXVkaW8ucGF0aCkgdXJscy5hZGQoYW5pbWFsLmF1ZGlvLnBhdGgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gUmV0dXJuIGFzIGFycmF5LCBwcmVmaXggd2l0aCAnLycgZm9yIGZldGNoXHJcbiAgcmV0dXJuIEFycmF5LmZyb20odXJscykubWFwKHBhdGggPT4gcGF0aC5zdGFydHNXaXRoKCcvJykgPyBwYXRoIDogJy8nICsgcGF0aCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGZXRjaGVzIHRoZSBsaXN0IG9mIGFsbCBmaWxlcyB0byBiZSBkb3dubG9hZGVkIGZvciBvZmZsaW5lIHVzZS5cclxuICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nW10+fSBBcnJheSBvZiBhc3NldCBVUkxzIChyZWxhdGl2ZSB0byBwdWJsaWMvKVxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE9mZmxpbmVBc3NldEZpbGVMaXN0KCkge1xyXG4gIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKCcvb2ZmbGluZUFzc2V0RmlsZUxpc3QuanNvbicpO1xyXG4gIGlmICghcmVzLm9rKSB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBvZmZsaW5lIGFzc2V0IGZpbGUgbGlzdCcpO1xyXG4gIHJldHVybiBhd2FpdCByZXMuanNvbigpO1xyXG59XHJcblxyXG4vKipcclxuICogTMO2c2NodCBhbGxlIGdlY2FjaHRlbiBBc3NldHMgKEJpbGRlciwgTVAzcyBldGMuKSBhdXMgSW5kZXhlZERCLlxyXG4gKiBXaXJkIHouQi4gYmVpIFZlcnNpb25zd2VjaHNlbCBhdWZnZXJ1ZmVuLlxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNsZWFyQWxsQXNzZXRDYWNoZSgpIHtcclxuICBjb25zdCBhbGxLZXlzID0gYXdhaXQga2V5cygpO1xyXG4gIGNvbnN0IGFzc2V0S2V5cyA9IGFsbEtleXMuZmlsdGVyKGtleSA9PiB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiBrZXkuc3RhcnRzV2l0aCgnYXNzZXRjYWNoZV8nKSk7XHJcbiAgZm9yIChjb25zdCBrZXkgb2YgYXNzZXRLZXlzKSB7XHJcbiAgICBhd2FpdCBkZWwoa2V5KTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMw7ZzY2h0IHdpcmtsaWNoIGFsbGUgQ2FjaGVzOiBJbmRleGVkREIsIExvY2FsU3RvcmFnZSwgQ2FjaGVzIEFQSSwgU2VydmljZSBXb3JrZXIuXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2xlYXJBbGxDYWNoZXNEZWVwKCkge1xyXG4gIC8vIDEuIEluZGV4ZWREQiAod2llIGJpc2hlcilcclxuICBhd2FpdCBjbGVhckFsbEFzc2V0Q2FjaGUoKTtcclxuXHJcbiAgLy8gMi4gTG9jYWxTdG9yYWdlIChudXIgcmVsZXZhbnRlIEtleXMsIG5pY2h0IGFsbGVzISlcclxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIE9iamVjdC5rZXlzKGxvY2FsU3RvcmFnZSkuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoJ2ltZ2NhY2hlXycpIHx8IGtleS5zdGFydHNXaXRoKCdrbGV4XycpIHx8IGtleS5zdGFydHNXaXRoKCdraW5kZXJsZXhpa29uXycpKSB7XHJcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvLyAzLiBDYWNoZXMgQVBJIChTZXJ2aWNlIFdvcmtlciBDYWNoZSlcclxuICBpZiAoJ2NhY2hlcycgaW4gd2luZG93KSB7XHJcbiAgICBjb25zdCBjYWNoZU5hbWVzID0gYXdhaXQgY2FjaGVzLmtleXMoKTtcclxuICAgIGZvciAoY29uc3QgbmFtZSBvZiBjYWNoZU5hbWVzKSB7XHJcbiAgICAgIGF3YWl0IGNhY2hlcy5kZWxldGUobmFtZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyA0LiBTZXJ2aWNlIFdvcmtlciBkZXJlZ2lzdHJpZXJlbiAob3B0aW9uYWwsIHdpcmQgYmVpbSBSZWxvYWQgbmV1IHJlZ2lzdHJpZXJ0KVxyXG4gIGlmICgnc2VydmljZVdvcmtlcicgaW4gbmF2aWdhdG9yKSB7XHJcbiAgICBjb25zdCByZWdzID0gYXdhaXQgbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIuZ2V0UmVnaXN0cmF0aW9ucygpO1xyXG4gICAgZm9yIChjb25zdCByZWcgb2YgcmVncykge1xyXG4gICAgICBhd2FpdCByZWcudW5yZWdpc3RlcigpO1xyXG4gICAgfVxyXG4gIH1cclxufSAiXSwibmFtZXMiOlsic2V0IiwiZ2V0IiwiZGVsIiwia2V5cyIsImdldENhY2hlS2V5IiwidXJsIiwidmVyc2lvbiIsImdldENhY2hlZEFzc2V0IiwiY2FjaGVLZXkiLCJjYWNoZWQiLCJlIiwiY29uc29sZSIsIndhcm4iLCJyZXNwb25zZSIsImZldGNoIiwib2siLCJFcnJvciIsImJsb2IiLCJiYXNlNjQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInJlYWRlciIsIkZpbGVSZWFkZXIiLCJvbmxvYWRlbmQiLCJyZXN1bHQiLCJvbmVycm9yIiwicmVhZEFzRGF0YVVSTCIsImNsZWFyQ2FjaGVkQXNzZXQiLCJnZXRDYWNoZWRKc29uIiwiaW5jbHVkZXMiLCJzZXAiLCJEYXRlIiwibm93IiwiSlNPTiIsInBhcnNlIiwidGV4dCIsImdldENhY2hlZEFzc2V0QXNCbG9iIiwic3BsaXQiLCJtaW1lU3RyaW5nIiwiYnl0ZVN0cmluZyIsImF0b2IiLCJhYiIsIkFycmF5QnVmZmVyIiwibGVuZ3RoIiwiaWEiLCJVaW50OEFycmF5IiwiaSIsImNoYXJDb2RlQXQiLCJCbG9iIiwidHlwZSIsImdldENhY2hlZEF1ZGlvQXNCbG9iIiwiZXh0cmFjdEFsbFJlZmVyZW5jZWRBc3NldFVybHMiLCJjYXRlZ29yeURhdGEiLCJhbmltYWxEYXRhIiwidXJscyIsIlNldCIsImltYWdlIiwicGF0aCIsImFkZCIsImF1ZGlvIiwiQXJyYXkiLCJpc0FycmF5Iiwic3ViY2F0ZWdvcmllcyIsInN1YiIsInRpZXJlIiwiYW5pbWFsIiwiZnJvbSIsIm1hcCIsInN0YXJ0c1dpdGgiLCJnZXRPZmZsaW5lQXNzZXRGaWxlTGlzdCIsInJlcyIsImpzb24iLCJjbGVhckFsbEFzc2V0Q2FjaGUiLCJhbGxLZXlzIiwiYXNzZXRLZXlzIiwiZmlsdGVyIiwia2V5IiwiY2xlYXJBbGxDYWNoZXNEZWVwIiwiT2JqZWN0IiwibG9jYWxTdG9yYWdlIiwiZm9yRWFjaCIsInJlbW92ZUl0ZW0iLCJ3aW5kb3ciLCJjYWNoZU5hbWVzIiwiY2FjaGVzIiwibmFtZSIsImRlbGV0ZSIsIm5hdmlnYXRvciIsInJlZ3MiLCJzZXJ2aWNlV29ya2VyIiwiZ2V0UmVnaXN0cmF0aW9ucyIsInJlZyIsInVucmVnaXN0ZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./utils/assetCache.js\n"));

/***/ })

});