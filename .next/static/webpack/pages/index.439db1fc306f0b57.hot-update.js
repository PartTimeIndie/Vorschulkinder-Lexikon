"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./components/Character.js":
/*!*********************************!*\
  !*** ./components/Character.js ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/image */ \"./node_modules/next/image.js\");\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_image__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _utils_assetCache__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/assetCache */ \"./utils/assetCache.js\");\n\nvar _s = $RefreshSig$();\n\n\n\n// Statische Variable um sicherzustellen dass Character nur EINMAL initialisiert wird\nlet characterInitialized = false;\n// Entferne die Hilfsfunktion getCharacterImageUrl\nconst Character = (param)=>{\n    let { currentContext = \"idle\", onEmotionChange } = param;\n    _s();\n    const [currentEmotion, setCurrentEmotion] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"idle\");\n    const [isRotating, setIsRotating] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [rotationPhase, setRotationPhase] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"idle\"); // 'idle', 'out', 'in'\n    const [availableEmotions, setAvailableEmotions] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([\n        \"idle\",\n        \"curious\"\n    ]);\n    const [hasLoaded, setHasLoaded] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(characterInitialized); // Für initiale Fly-In Animation - einmal für immer\n    const [lastProcessedContext, setLastProcessedContext] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null); // Verhindert mehrfache Emotion-Wechsel\n    const [lastEmotionChangeTime, setLastEmotionChangeTime] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0); // Cooldown für Emotion-Changes\n    const autoResetTimer = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const emotionChangeTimer = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Character-Bilder-Varianten definieren\n    const characterVariants = {\n        idle: [\n            \"/Characters/Character-idle.png\",\n            \"/Characters/Character-idle-2.png\",\n            \"/Characters/Character-idle-3.png\"\n        ],\n        excited: [\n            \"/Characters/Character-excited.png\",\n            \"/Characters/Character-excited-2.png\",\n            \"/Characters/Character-excited-3.png\"\n        ],\n        curious: [\n            \"/Characters/Character-curious.png\",\n            \"/Characters/Character-curious-2.png\",\n            \"/Characters/Character-curious-3.png\"\n        ],\n        surprised: [\n            \"/Characters/Character-surprised.png\",\n            \"/Characters/Character-surprised-2.png\",\n            \"/Characters/Character-surprised-3.png\"\n        ],\n        thinking: [\n            \"/Characters/Character-thinking.png\",\n            \"/Characters/Character-thinking-2.png\",\n            \"/Characters/Character-thinking-3.png\"\n        ],\n        laughing: [\n            \"/Characters/Character-laughing.png\",\n            \"/Characters/Character-laughing-2.png\"\n        ],\n        exploring: [\n            \"/Characters/Character-excited.png\",\n            \"/Characters/Character-excited-2.png\",\n            \"/Characters/Character-excited-3.png\"\n        ],\n        scared: [\n            \"/Characters/Character-surprised.png\",\n            \"/Characters/Character-surprised-2.png\",\n            \"/Characters/Character-surprised-3.png\"\n        ]\n    };\n    // State für gewählte Variante pro Emotion\n    const [selectedVariant, setSelectedVariant] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"/Characters/Character-idle.png\");\n    const [imgLoaded, setImgLoaded] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [imgSrc, setImgSrc] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"/Characters/Character-idle.png\");\n    // Whenever selectedVariant changes, try to load from cache\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        let isMounted = true;\n        if (!selectedVariant) return;\n        (0,_utils_assetCache__WEBPACK_IMPORTED_MODULE_3__.getCachedAsset)(selectedVariant).then((base64)=>{\n            if (isMounted && base64) setImgSrc(base64);\n            else if (isMounted) setImgSrc(selectedVariant);\n        }).catch(()=>{\n            if (isMounted) setImgSrc(selectedVariant);\n        });\n        return ()=>{\n            isMounted = false;\n        };\n    }, [\n        selectedVariant\n    ]);\n    // Zufällige Variante für Emotion wählen und speichern (NIEMALS die gleiche)\n    const selectVariantForEmotion = (emotion)=>{\n        const variants = characterVariants[emotion] || characterVariants.idle;\n        // Wenn nur eine Variante vorhanden, diese nehmen\n        if (variants.length === 1) {\n            const variant = variants[0];\n            setSelectedVariant(variant);\n            return variant;\n        }\n        // Aktuelle Variante rausfiltern um Wiederholung zu vermeiden\n        const otherVariants = variants.filter((variant)=>variant !== selectedVariant);\n        // Falls alle Varianten die gleiche sind (sollte nicht passieren), erste nehmen\n        if (otherVariants.length === 0) {\n            const variant = variants[0];\n            setSelectedVariant(variant);\n            return variant;\n        }\n        // Zufällige andere Variante wählen\n        const randomVariant = otherVariants[Math.floor(Math.random() * otherVariants.length)];\n        setSelectedVariant(randomVariant);\n        return randomVariant;\n    };\n    // Zufällige Emotion aus verfügbaren Emotionen wählen\n    const getRandomEmotion = function() {\n        let emotions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : availableEmotions;\n        const filtered = emotions.filter((e)=>e !== currentEmotion);\n        if (filtered.length === 0) return emotions[0];\n        return filtered[Math.floor(Math.random() * filtered.length)];\n    };\n    // Emotion-Wechsel mit ursprünglicher Flip-Animation\n    const changeEmotion = function(newEmotion) {\n        let immediate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        console.log(\"\\uD83C\\uDFAD Emotion change: \".concat(currentEmotion, \" → \").concat(newEmotion, \" (immediate: \").concat(immediate, \")\"));\n        if (newEmotion === currentEmotion) {\n            console.log(\"\\uD83C\\uDFAD Same emotion, skipping\");\n            return;\n        }\n        if (immediate) {\n            // Direkter Wechsel ohne Animation\n            console.log(\"\\uD83C\\uDFAD Immediate change to \".concat(newEmotion));\n            setCurrentEmotion(newEmotion);\n            selectVariantForEmotion(newEmotion);\n            return;\n        }\n        // Flip-Animation: Raus -> Bild wechseln -> Rein\n        console.log(\"\\uD83C\\uDFAD Starting flip animation: out → change → in\");\n        setIsRotating(true);\n        setRotationPhase(\"out\");\n        // Nach Raus-Animation (200ms): Bild wechseln\n        setTimeout(()=>{\n            console.log(\"\\uD83C\\uDFAD Flip animation: Changing image to \".concat(newEmotion));\n            setCurrentEmotion(newEmotion);\n            selectVariantForEmotion(newEmotion);\n            setRotationPhase(\"in\");\n            // Nach Rein-Animation (200ms): Animation beenden\n            setTimeout(()=>{\n                console.log(\"\\uD83C\\uDFAD Flip animation: Complete!\");\n                setRotationPhase(\"idle\");\n                setIsRotating(false);\n            }, 200);\n        }, 200);\n    };\n    // Auto-Reset entfernt - Character wechselt nur bei Interaktionen\n    // Context-abhängige Emotionen laden\n    const loadContextEmotions = async (context)=>{\n        console.log(\"\\uD83C\\uDFAD loadContextEmotions called with context: '\".concat(context, \"' (lastProcessed: '\").concat(lastProcessedContext, \"')\"));\n        try {\n            // Statt API: Definiere die Emotions-Logik clientseitig oder lade aus statischer Datei\n            // Beispiel: Mapping von Context zu Emotions\n            const contextEmotionMap = {\n                idle: [\n                    \"idle\",\n                    \"curious\"\n                ],\n                main: [\n                    \"excited\",\n                    \"curious\",\n                    \"idle\"\n                ],\n                category: [\n                    \"curious\",\n                    \"thinking\",\n                    \"excited\"\n                ],\n                animals: [\n                    \"excited\",\n                    \"surprised\",\n                    \"laughing\"\n                ],\n                default: [\n                    \"idle\",\n                    \"curious\",\n                    \"excited\",\n                    \"surprised\",\n                    \"thinking\",\n                    \"laughing\"\n                ]\n            };\n            const emotions = contextEmotionMap[context] || contextEmotionMap.default;\n            setAvailableEmotions(emotions);\n            // Der Rest bleibt gleich wie vorher\n            const now = Date.now();\n            const timeSinceLastChange = now - lastEmotionChangeTime;\n            const EMOTION_COOLDOWN = 2000; // 2 Sekunden Cooldown\n            console.log(\"\\uD83C\\uDFAD Context check: context=\".concat(context, \", lastProcessed=\").concat(lastProcessedContext, \", cooldown=\").concat(timeSinceLastChange, \"ms\"));\n            if (context !== \"idle\" && context !== lastProcessedContext && timeSinceLastChange >= EMOTION_COOLDOWN) {\n                console.log(\"\\uD83C\\uDFAD TRIGGERING emotion change for context '\".concat(context, \"'\"));\n                const randomEmotion = emotions[Math.floor(Math.random() * emotions.length)];\n                changeEmotion(randomEmotion, false); // Mit Flip-Animation\n                setLastProcessedContext(context); // Merke dass wir diesen Context schon verarbeitet haben\n                setLastEmotionChangeTime(now); // Setze Cooldown-Timer\n            } else if (context === lastProcessedContext) {\n                console.log(\"\\uD83C\\uDFAD BLOCKED: Context '\".concat(context, \"' already processed\"));\n            } else if (timeSinceLastChange < EMOTION_COOLDOWN) {\n                console.log(\"\\uD83C\\uDFAD BLOCKED: Cooldown active (\".concat(timeSinceLastChange, \"ms < \").concat(EMOTION_COOLDOWN, \"ms)\"));\n            } else if (context === \"idle\") {\n                // Bei idle-Context: Reset lastProcessedContext für nächste Interaktion (aber kein Cooldown Reset)\n                console.log(\"\\uD83C\\uDFAD RESET: Idle context, clearing lastProcessedContext\");\n                setLastProcessedContext(null);\n            // Character wird NICHT neu instanziert, nur hasLoaded bleibt true\n            }\n        } catch (error) {\n            console.error(\"Error loading context emotions:\", error);\n            setAvailableEmotions([\n                \"idle\",\n                \"curious\"\n            ]);\n        }\n    };\n    // Zufälliges Lachen abspielen (ohne Voice-Overs zu unterbrechen)\n    const playRandomLaughter = ()=>{\n        const laughterFiles = [\n            \"/audio/LaughingKid/laughing-1.wav\",\n            \"/audio/LaughingKid/laughing-2.wav\",\n            \"/audio/LaughingKid/laughing-3.wav\",\n            \"/audio/LaughingKid/laughing-4.wav\",\n            \"/audio/LaughingKid/laughing-5.wav\",\n            \"/audio/LaughingKid/laughing-6.wav\",\n            \"/audio/LaughingKid/laughing-7.wav\"\n        ];\n        // Zufällige Lacher-Datei auswählen\n        const randomLaughter = laughterFiles[Math.floor(Math.random() * laughterFiles.length)];\n        try {\n            // SEPARATES Audio-Element für Lacher (nicht global!)\n            const laughterAudio = new Audio(randomLaughter);\n            laughterAudio.volume = 0.7; // Etwas leiser als Voice-Overs\n            laughterAudio.play().catch((err)=>{\n                console.log(\"Lacher-Audio autoplay verhindert:\", err);\n            });\n            console.log(\"\\uD83E\\uDD23 Lacher abgespielt:\", randomLaughter);\n        } catch (error) {\n            console.error(\"Lacher-Audio-Fehler:\", error);\n        }\n    };\n    // Character antippen - Rotation, Emotion-Wechsel UND Lachen\n    const handleCharacterClick = ()=>{\n        // Zu laughing oder excited wechseln, aber NIEMALS die aktuelle Emotion\n        const happyEmotions = [\n            \"laughing\",\n            \"excited\"\n        ];\n        let randomHappyEmotion;\n        // Andere Emotion wählen als die aktuelle\n        if (currentEmotion === \"laughing\") {\n            randomHappyEmotion = \"excited\";\n        } else if (currentEmotion === \"excited\") {\n            randomHappyEmotion = \"laughing\";\n        } else {\n            // Wenn weder laughing noch excited, zufällig wählen\n            randomHappyEmotion = happyEmotions[Math.floor(Math.random() * happyEmotions.length)];\n        }\n        changeEmotion(randomHappyEmotion, false); // Mit Flip-Animation\n        setLastEmotionChangeTime(Date.now()); // Cooldown-Timer auch bei direktem Character-Klick setzen\n        // Zufälliges Lachen abspielen (parallel zu Voice-Overs)\n        playRandomLaughter();\n        // Callback für Emotion-Änderung\n        if (onEmotionChange) {\n            onEmotionChange(randomHappyEmotion);\n        }\n    };\n    // Initial Fly-In Animation starten - NUR EINMAL in der gesamten App-Laufzeit\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!characterInitialized) {\n            console.log(\"\\uD83C\\uDFAD Character FIRST TIME INITIALIZATION\");\n            characterInitialized = true; // Setze statische Variable\n            // Nach kurzer Verzögerung Character reinfliegen lassen\n            const loadTimer = setTimeout(()=>{\n                console.log(\"\\uD83C\\uDFAD Setting hasLoaded to true\");\n                setHasLoaded(true);\n            }, 300);\n            return ()=>clearTimeout(loadTimer);\n        } else {\n            console.log(\"\\uD83C\\uDFAD Character ALREADY INITIALIZED - setting hasLoaded immediately\");\n            setHasLoaded(true); // Bei Re-Render sofort auf loaded setzen\n        }\n    }, []);\n    // Context-Änderungen überwachen - mit Ref um doppelte Aufrufe zu verhindern\n    const lastContextRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (currentContext && currentContext !== lastContextRef.current) {\n            console.log(\"\\uD83C\\uDFAD Processing NEW context: '\".concat(currentContext, \"'\"));\n            lastContextRef.current = currentContext;\n            loadContextEmotions(currentContext);\n        }\n    }, [\n        currentContext\n    ]);\n    // Cleanup Timer\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        return ()=>{\n            if (autoResetTimer.current) clearTimeout(autoResetTimer.current);\n            if (emotionChangeTimer.current) clearTimeout(emotionChangeTimer.current);\n        };\n    }, []);\n    // Preload image via Base64 cache, but do not use it for rendering\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!selectedVariant) return;\n        (0,_utils_assetCache__WEBPACK_IMPORTED_MODULE_3__.getCachedAsset)(selectedVariant).catch(()=>{});\n    }, [\n        selectedVariant\n    ]);\n    // Track loading state for the real image\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        let didCancel = false;\n        let fallbackTimer;\n        setImgLoaded(false);\n        if (selectedVariant) {\n            fallbackTimer = setTimeout(()=>{\n                if (!didCancel) setImgLoaded(true);\n            }, 500);\n        }\n        return ()=>{\n            didCancel = true;\n            if (fallbackTimer) clearTimeout(fallbackTimer);\n        };\n    }, [\n        selectedVariant\n    ]);\n    // Animation-Klassen bestimmen\n    const getAnimationClasses = ()=>{\n        let classes = \"character-image\";\n        // Initial Fly-In Animation beim ersten Laden\n        if (!hasLoaded) {\n            classes += \" character-fly-in\";\n            console.log(\"\\uD83C\\uDFA8 CSS Classes: \".concat(classes, \" (fly-in)\"));\n            return classes;\n        }\n        // Rotation-Animation hat Priorität\n        if (rotationPhase === \"out\") {\n            classes += \" character-rotate-out\";\n            console.log(\"\\uD83C\\uDFA8 CSS Classes: \".concat(classes, \" (rotating OUT)\"));\n        } else if (rotationPhase === \"in\") {\n            classes += \" character-rotate-in\";\n            console.log(\"\\uD83C\\uDFA8 CSS Classes: \".concat(classes, \" (rotating IN)\"));\n        } else if (rotationPhase === \"idle\" && !isRotating) {\n            // Subtile Loop-Animation nur wenn wirklich idle\n            classes += \" character-subtle-animation\";\n            console.log(\"\\uD83C\\uDFA8 CSS Classes: \".concat(classes, \" (subtle idle)\"));\n        } else {\n            console.log(\"\\uD83C\\uDFA8 CSS Classes: \".concat(classes, \" (no extra animation)\"));\n        }\n        return classes;\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"character-container\",\n        onClick: handleCharacterClick,\n        title: \"Character antippen f\\xfcr Emotionen!\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n            src: imgSrc,\n            alt: \"Character \".concat(currentEmotion),\n            width: 120,\n            height: 150,\n            className: getAnimationClasses(),\n            style: {\n                objectFit: \"contain\",\n                position: \"relative\",\n                zIndex: 1,\n                opacity: imgLoaded ? 1 : 0,\n                transition: \"opacity 0.2s\"\n            },\n            onLoad: ()=>setImgLoaded(true),\n            onError: ()=>setImgLoaded(true)\n        }, void 0, false, {\n            fileName: \"D:\\\\gitrepros\\\\Vorschulkinder Lexikon\\\\components\\\\Character.js\",\n            lineNumber: 355,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"D:\\\\gitrepros\\\\Vorschulkinder Lexikon\\\\components\\\\Character.js\",\n        lineNumber: 350,\n        columnNumber: 5\n    }, undefined);\n};\n_s(Character, \"Ud3c6ouTSDCcbMKir0SEd/xuaHc=\");\n_c = Character;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Character); // Cache-Refresh: Updated Character Animation and removed isBouncing \nvar _c;\n$RefreshReg$(_c, \"Character\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q2xELGdEQUFnRDtZQUNoRHFGLFdBQVc7WUFDWGxDLFFBQVFDLEdBQUcsQ0FBQyw2QkFBMkIsT0FBUmlDLFNBQVE7UUFDekMsT0FBTztZQUNMbEMsUUFBUUMsR0FBRyxDQUFDLDZCQUEyQixPQUFSaUMsU0FBUTtRQUN6QztRQUVBLE9BQU9BO0lBQ1Q7SUFFQSxxQkFDRSw4REFBQ0M7UUFDQ0MsV0FBVTtRQUNWQyxTQUFTYjtRQUNUYyxPQUFNO2tCQUVOLDRFQUFDQztZQUNDQyxLQUFLaEU7WUFDTGlFLEtBQUssYUFBNEIsT0FBZjlGO1lBQ2xCK0YsT0FBTztZQUNQQyxRQUFRO1lBQ1JQLFdBQVdIO1lBQ1hXLE9BQU87Z0JBQUVDLFdBQVc7Z0JBQVdDLFVBQVU7Z0JBQVlDLFFBQVE7Z0JBQUdDLFNBQVMxRSxZQUFZLElBQUk7Z0JBQUcyRSxZQUFZO1lBQWU7WUFDdkhDLFFBQVEsSUFBTTNFLGFBQWE7WUFDM0I0RSxTQUFTLElBQU01RSxhQUFhOzs7Ozs7Ozs7OztBQUlwQztHQXJXTS9CO0tBQUFBO0FBdVdOLCtEQUFlQSxTQUFTQSxFQUFDLENBQ3pCLHFFQUFxRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0NoYXJhY3Rlci5qcz9lMjdmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBJbWFnZSBmcm9tICduZXh0L2ltYWdlJztcbmltcG9ydCB7IGdldENhY2hlZEFzc2V0IH0gZnJvbSAnLi4vdXRpbHMvYXNzZXRDYWNoZSc7XG5cbi8vIFN0YXRpc2NoZSBWYXJpYWJsZSB1bSBzaWNoZXJ6dXN0ZWxsZW4gZGFzcyBDaGFyYWN0ZXIgbnVyIEVJTk1BTCBpbml0aWFsaXNpZXJ0IHdpcmRcbmxldCBjaGFyYWN0ZXJJbml0aWFsaXplZCA9IGZhbHNlO1xuXG4vLyBFbnRmZXJuZSBkaWUgSGlsZnNmdW5rdGlvbiBnZXRDaGFyYWN0ZXJJbWFnZVVybFxuXG5jb25zdCBDaGFyYWN0ZXIgPSAoeyBjdXJyZW50Q29udGV4dCA9ICdpZGxlJywgb25FbW90aW9uQ2hhbmdlIH0pID0+IHtcbiAgY29uc3QgW2N1cnJlbnRFbW90aW9uLCBzZXRDdXJyZW50RW1vdGlvbl0gPSB1c2VTdGF0ZSgnaWRsZScpO1xuICBjb25zdCBbaXNSb3RhdGluZywgc2V0SXNSb3RhdGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtyb3RhdGlvblBoYXNlLCBzZXRSb3RhdGlvblBoYXNlXSA9IHVzZVN0YXRlKCdpZGxlJyk7IC8vICdpZGxlJywgJ291dCcsICdpbidcbiAgY29uc3QgW2F2YWlsYWJsZUVtb3Rpb25zLCBzZXRBdmFpbGFibGVFbW90aW9uc10gPSB1c2VTdGF0ZShbJ2lkbGUnLCAnY3VyaW91cyddKTtcbiAgY29uc3QgW2hhc0xvYWRlZCwgc2V0SGFzTG9hZGVkXSA9IHVzZVN0YXRlKGNoYXJhY3RlckluaXRpYWxpemVkKTsgLy8gRsO8ciBpbml0aWFsZSBGbHktSW4gQW5pbWF0aW9uIC0gZWlubWFsIGbDvHIgaW1tZXJcbiAgY29uc3QgW2xhc3RQcm9jZXNzZWRDb250ZXh0LCBzZXRMYXN0UHJvY2Vzc2VkQ29udGV4dF0gPSB1c2VTdGF0ZShudWxsKTsgLy8gVmVyaGluZGVydCBtZWhyZmFjaGUgRW1vdGlvbi1XZWNoc2VsXG4gIGNvbnN0IFtsYXN0RW1vdGlvbkNoYW5nZVRpbWUsIHNldExhc3RFbW90aW9uQ2hhbmdlVGltZV0gPSB1c2VTdGF0ZSgwKTsgLy8gQ29vbGRvd24gZsO8ciBFbW90aW9uLUNoYW5nZXNcbiAgXG4gIGNvbnN0IGF1dG9SZXNldFRpbWVyID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBlbW90aW9uQ2hhbmdlVGltZXIgPSB1c2VSZWYobnVsbCk7XG5cbiAgLy8gQ2hhcmFjdGVyLUJpbGRlci1WYXJpYW50ZW4gZGVmaW5pZXJlblxuICBjb25zdCBjaGFyYWN0ZXJWYXJpYW50cyA9IHtcbiAgICBpZGxlOiBbXG4gICAgICAnL0NoYXJhY3RlcnMvQ2hhcmFjdGVyLWlkbGUucG5nJyxcbiAgICAgICcvQ2hhcmFjdGVycy9DaGFyYWN0ZXItaWRsZS0yLnBuZycsXG4gICAgICAnL0NoYXJhY3RlcnMvQ2hhcmFjdGVyLWlkbGUtMy5wbmcnXG4gICAgXSxcbiAgICBleGNpdGVkOiBbXG4gICAgICAnL0NoYXJhY3RlcnMvQ2hhcmFjdGVyLWV4Y2l0ZWQucG5nJyxcbiAgICAgICcvQ2hhcmFjdGVycy9DaGFyYWN0ZXItZXhjaXRlZC0yLnBuZycsXG4gICAgICAnL0NoYXJhY3RlcnMvQ2hhcmFjdGVyLWV4Y2l0ZWQtMy5wbmcnXG4gICAgXSxcbiAgICBjdXJpb3VzOiBbXG4gICAgICAnL0NoYXJhY3RlcnMvQ2hhcmFjdGVyLWN1cmlvdXMucG5nJyxcbiAgICAgICcvQ2hhcmFjdGVycy9DaGFyYWN0ZXItY3VyaW91cy0yLnBuZycsXG4gICAgICAnL0NoYXJhY3RlcnMvQ2hhcmFjdGVyLWN1cmlvdXMtMy5wbmcnXG4gICAgXSxcbiAgICBzdXJwcmlzZWQ6IFtcbiAgICAgICcvQ2hhcmFjdGVycy9DaGFyYWN0ZXItc3VycHJpc2VkLnBuZycsXG4gICAgICAnL0NoYXJhY3RlcnMvQ2hhcmFjdGVyLXN1cnByaXNlZC0yLnBuZycsXG4gICAgICAnL0NoYXJhY3RlcnMvQ2hhcmFjdGVyLXN1cnByaXNlZC0zLnBuZydcbiAgICBdLFxuICAgIHRoaW5raW5nOiBbXG4gICAgICAnL0NoYXJhY3RlcnMvQ2hhcmFjdGVyLXRoaW5raW5nLnBuZycsXG4gICAgICAnL0NoYXJhY3RlcnMvQ2hhcmFjdGVyLXRoaW5raW5nLTIucG5nJyxcbiAgICAgICcvQ2hhcmFjdGVycy9DaGFyYWN0ZXItdGhpbmtpbmctMy5wbmcnXG4gICAgXSxcbiAgICBsYXVnaGluZzogW1xuICAgICAgJy9DaGFyYWN0ZXJzL0NoYXJhY3Rlci1sYXVnaGluZy5wbmcnLFxuICAgICAgJy9DaGFyYWN0ZXJzL0NoYXJhY3Rlci1sYXVnaGluZy0yLnBuZydcbiAgICBdLFxuICAgIGV4cGxvcmluZzogW1xuICAgICAgJy9DaGFyYWN0ZXJzL0NoYXJhY3Rlci1leGNpdGVkLnBuZycsXG4gICAgICAnL0NoYXJhY3RlcnMvQ2hhcmFjdGVyLWV4Y2l0ZWQtMi5wbmcnLFxuICAgICAgJy9DaGFyYWN0ZXJzL0NoYXJhY3Rlci1leGNpdGVkLTMucG5nJ1xuICAgIF0sXG4gICAgc2NhcmVkOiBbXG4gICAgICAnL0NoYXJhY3RlcnMvQ2hhcmFjdGVyLXN1cnByaXNlZC5wbmcnLFxuICAgICAgJy9DaGFyYWN0ZXJzL0NoYXJhY3Rlci1zdXJwcmlzZWQtMi5wbmcnLFxuICAgICAgJy9DaGFyYWN0ZXJzL0NoYXJhY3Rlci1zdXJwcmlzZWQtMy5wbmcnXG4gICAgXSxcbiAgfTtcblxuICAvLyBTdGF0ZSBmw7xyIGdld8OkaGx0ZSBWYXJpYW50ZSBwcm8gRW1vdGlvblxuICBjb25zdCBbc2VsZWN0ZWRWYXJpYW50LCBzZXRTZWxlY3RlZFZhcmlhbnRdID0gdXNlU3RhdGUoJy9DaGFyYWN0ZXJzL0NoYXJhY3Rlci1pZGxlLnBuZycpO1xuICBjb25zdCBbaW1nTG9hZGVkLCBzZXRJbWdMb2FkZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbaW1nU3JjLCBzZXRJbWdTcmNdID0gdXNlU3RhdGUoJy9DaGFyYWN0ZXJzL0NoYXJhY3Rlci1pZGxlLnBuZycpO1xuXG4gIC8vIFdoZW5ldmVyIHNlbGVjdGVkVmFyaWFudCBjaGFuZ2VzLCB0cnkgdG8gbG9hZCBmcm9tIGNhY2hlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IGlzTW91bnRlZCA9IHRydWU7XG4gICAgaWYgKCFzZWxlY3RlZFZhcmlhbnQpIHJldHVybjtcbiAgICBnZXRDYWNoZWRBc3NldChzZWxlY3RlZFZhcmlhbnQpXG4gICAgICAudGhlbihiYXNlNjQgPT4ge1xuICAgICAgICBpZiAoaXNNb3VudGVkICYmIGJhc2U2NCkgc2V0SW1nU3JjKGJhc2U2NCk7XG4gICAgICAgIGVsc2UgaWYgKGlzTW91bnRlZCkgc2V0SW1nU3JjKHNlbGVjdGVkVmFyaWFudCk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKCgpID0+IHtcbiAgICAgICAgaWYgKGlzTW91bnRlZCkgc2V0SW1nU3JjKHNlbGVjdGVkVmFyaWFudCk7XG4gICAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4geyBpc01vdW50ZWQgPSBmYWxzZTsgfTtcbiAgfSwgW3NlbGVjdGVkVmFyaWFudF0pO1xuXG4gIC8vIFp1ZsOkbGxpZ2UgVmFyaWFudGUgZsO8ciBFbW90aW9uIHfDpGhsZW4gdW5kIHNwZWljaGVybiAoTklFTUFMUyBkaWUgZ2xlaWNoZSlcbiAgY29uc3Qgc2VsZWN0VmFyaWFudEZvckVtb3Rpb24gPSAoZW1vdGlvbikgPT4ge1xuICAgIGNvbnN0IHZhcmlhbnRzID0gY2hhcmFjdGVyVmFyaWFudHNbZW1vdGlvbl0gfHwgY2hhcmFjdGVyVmFyaWFudHMuaWRsZTtcbiAgICBcbiAgICAvLyBXZW5uIG51ciBlaW5lIFZhcmlhbnRlIHZvcmhhbmRlbiwgZGllc2UgbmVobWVuXG4gICAgaWYgKHZhcmlhbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgdmFyaWFudCA9IHZhcmlhbnRzWzBdO1xuICAgICAgc2V0U2VsZWN0ZWRWYXJpYW50KHZhcmlhbnQpO1xuICAgICAgcmV0dXJuIHZhcmlhbnQ7XG4gICAgfVxuICAgIFxuICAgIC8vIEFrdHVlbGxlIFZhcmlhbnRlIHJhdXNmaWx0ZXJuIHVtIFdpZWRlcmhvbHVuZyB6dSB2ZXJtZWlkZW5cbiAgICBjb25zdCBvdGhlclZhcmlhbnRzID0gdmFyaWFudHMuZmlsdGVyKHZhcmlhbnQgPT4gdmFyaWFudCAhPT0gc2VsZWN0ZWRWYXJpYW50KTtcbiAgICBcbiAgICAvLyBGYWxscyBhbGxlIFZhcmlhbnRlbiBkaWUgZ2xlaWNoZSBzaW5kIChzb2xsdGUgbmljaHQgcGFzc2llcmVuKSwgZXJzdGUgbmVobWVuXG4gICAgaWYgKG90aGVyVmFyaWFudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb25zdCB2YXJpYW50ID0gdmFyaWFudHNbMF07XG4gICAgICBzZXRTZWxlY3RlZFZhcmlhbnQodmFyaWFudCk7XG4gICAgICByZXR1cm4gdmFyaWFudDtcbiAgICB9XG4gICAgXG4gICAgLy8gWnVmw6RsbGlnZSBhbmRlcmUgVmFyaWFudGUgd8OkaGxlblxuICAgIGNvbnN0IHJhbmRvbVZhcmlhbnQgPSBvdGhlclZhcmlhbnRzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG90aGVyVmFyaWFudHMubGVuZ3RoKV07XG4gICAgc2V0U2VsZWN0ZWRWYXJpYW50KHJhbmRvbVZhcmlhbnQpO1xuICAgIHJldHVybiByYW5kb21WYXJpYW50O1xuICB9O1xuXG4gIC8vIFp1ZsOkbGxpZ2UgRW1vdGlvbiBhdXMgdmVyZsO8Z2JhcmVuIEVtb3Rpb25lbiB3w6RobGVuXG4gIGNvbnN0IGdldFJhbmRvbUVtb3Rpb24gPSAoZW1vdGlvbnMgPSBhdmFpbGFibGVFbW90aW9ucykgPT4ge1xuICAgIGNvbnN0IGZpbHRlcmVkID0gZW1vdGlvbnMuZmlsdGVyKGUgPT4gZSAhPT0gY3VycmVudEVtb3Rpb24pO1xuICAgIGlmIChmaWx0ZXJlZC5sZW5ndGggPT09IDApIHJldHVybiBlbW90aW9uc1swXTtcbiAgICByZXR1cm4gZmlsdGVyZWRbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogZmlsdGVyZWQubGVuZ3RoKV07XG4gIH07XG5cbiAgLy8gRW1vdGlvbi1XZWNoc2VsIG1pdCB1cnNwcsO8bmdsaWNoZXIgRmxpcC1BbmltYXRpb25cbiAgY29uc3QgY2hhbmdlRW1vdGlvbiA9IChuZXdFbW90aW9uLCBpbW1lZGlhdGUgPSBmYWxzZSkgPT4ge1xuICAgIGNvbnNvbGUubG9nKGDwn46tIEVtb3Rpb24gY2hhbmdlOiAke2N1cnJlbnRFbW90aW9ufSDihpIgJHtuZXdFbW90aW9ufSAoaW1tZWRpYXRlOiAke2ltbWVkaWF0ZX0pYCk7XG4gICAgXG4gICAgaWYgKG5ld0Vtb3Rpb24gPT09IGN1cnJlbnRFbW90aW9uKSB7XG4gICAgICBjb25zb2xlLmxvZyhg8J+OrSBTYW1lIGVtb3Rpb24sIHNraXBwaW5nYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGlmIChpbW1lZGlhdGUpIHtcbiAgICAgIC8vIERpcmVrdGVyIFdlY2hzZWwgb2huZSBBbmltYXRpb25cbiAgICAgIGNvbnNvbGUubG9nKGDwn46tIEltbWVkaWF0ZSBjaGFuZ2UgdG8gJHtuZXdFbW90aW9ufWApO1xuICAgICAgc2V0Q3VycmVudEVtb3Rpb24obmV3RW1vdGlvbik7XG4gICAgICBzZWxlY3RWYXJpYW50Rm9yRW1vdGlvbihuZXdFbW90aW9uKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gRmxpcC1BbmltYXRpb246IFJhdXMgLT4gQmlsZCB3ZWNoc2VsbiAtPiBSZWluXG4gICAgY29uc29sZS5sb2coYPCfjq0gU3RhcnRpbmcgZmxpcCBhbmltYXRpb246IG91dCDihpIgY2hhbmdlIOKGkiBpbmApO1xuICAgIHNldElzUm90YXRpbmcodHJ1ZSk7XG4gICAgc2V0Um90YXRpb25QaGFzZSgnb3V0Jyk7XG4gICAgXG4gICAgLy8gTmFjaCBSYXVzLUFuaW1hdGlvbiAoMjAwbXMpOiBCaWxkIHdlY2hzZWxuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyhg8J+OrSBGbGlwIGFuaW1hdGlvbjogQ2hhbmdpbmcgaW1hZ2UgdG8gJHtuZXdFbW90aW9ufWApO1xuICAgICAgc2V0Q3VycmVudEVtb3Rpb24obmV3RW1vdGlvbik7XG4gICAgICBzZWxlY3RWYXJpYW50Rm9yRW1vdGlvbihuZXdFbW90aW9uKTtcbiAgICAgIHNldFJvdGF0aW9uUGhhc2UoJ2luJyk7XG4gICAgICBcbiAgICAgIC8vIE5hY2ggUmVpbi1BbmltYXRpb24gKDIwMG1zKTogQW5pbWF0aW9uIGJlZW5kZW5cbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZyhg8J+OrSBGbGlwIGFuaW1hdGlvbjogQ29tcGxldGUhYCk7XG4gICAgICAgIHNldFJvdGF0aW9uUGhhc2UoJ2lkbGUnKTtcbiAgICAgICAgc2V0SXNSb3RhdGluZyhmYWxzZSk7XG4gICAgICB9LCAyMDApO1xuICAgIH0sIDIwMCk7XG4gIH07XG5cbiAgLy8gQXV0by1SZXNldCBlbnRmZXJudCAtIENoYXJhY3RlciB3ZWNoc2VsdCBudXIgYmVpIEludGVyYWt0aW9uZW5cblxuICAvLyBDb250ZXh0LWFiaMOkbmdpZ2UgRW1vdGlvbmVuIGxhZGVuXG4gIGNvbnN0IGxvYWRDb250ZXh0RW1vdGlvbnMgPSBhc3luYyAoY29udGV4dCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKGDwn46tIGxvYWRDb250ZXh0RW1vdGlvbnMgY2FsbGVkIHdpdGggY29udGV4dDogJyR7Y29udGV4dH0nIChsYXN0UHJvY2Vzc2VkOiAnJHtsYXN0UHJvY2Vzc2VkQ29udGV4dH0nKWApO1xuICAgIHRyeSB7XG4gICAgICAvLyBTdGF0dCBBUEk6IERlZmluaWVyZSBkaWUgRW1vdGlvbnMtTG9naWsgY2xpZW50c2VpdGlnIG9kZXIgbGFkZSBhdXMgc3RhdGlzY2hlciBEYXRlaVxuICAgICAgLy8gQmVpc3BpZWw6IE1hcHBpbmcgdm9uIENvbnRleHQgenUgRW1vdGlvbnNcbiAgICAgIGNvbnN0IGNvbnRleHRFbW90aW9uTWFwID0ge1xuICAgICAgICBpZGxlOiBbJ2lkbGUnLCAnY3VyaW91cyddLFxuICAgICAgICBtYWluOiBbJ2V4Y2l0ZWQnLCAnY3VyaW91cycsICdpZGxlJ10sXG4gICAgICAgIGNhdGVnb3J5OiBbJ2N1cmlvdXMnLCAndGhpbmtpbmcnLCAnZXhjaXRlZCddLFxuICAgICAgICBhbmltYWxzOiBbJ2V4Y2l0ZWQnLCAnc3VycHJpc2VkJywgJ2xhdWdoaW5nJ10sXG4gICAgICAgIGRlZmF1bHQ6IFsnaWRsZScsICdjdXJpb3VzJywgJ2V4Y2l0ZWQnLCAnc3VycHJpc2VkJywgJ3RoaW5raW5nJywgJ2xhdWdoaW5nJ11cbiAgICAgIH07XG4gICAgICBjb25zdCBlbW90aW9ucyA9IGNvbnRleHRFbW90aW9uTWFwW2NvbnRleHRdIHx8IGNvbnRleHRFbW90aW9uTWFwLmRlZmF1bHQ7XG4gICAgICBzZXRBdmFpbGFibGVFbW90aW9ucyhlbW90aW9ucyk7XG4gICAgICAvLyBEZXIgUmVzdCBibGVpYnQgZ2xlaWNoIHdpZSB2b3JoZXJcbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgdGltZVNpbmNlTGFzdENoYW5nZSA9IG5vdyAtIGxhc3RFbW90aW9uQ2hhbmdlVGltZTtcbiAgICAgICAgY29uc3QgRU1PVElPTl9DT09MRE9XTiA9IDIwMDA7IC8vIDIgU2VrdW5kZW4gQ29vbGRvd25cbiAgICAgICAgY29uc29sZS5sb2coYPCfjq0gQ29udGV4dCBjaGVjazogY29udGV4dD0ke2NvbnRleHR9LCBsYXN0UHJvY2Vzc2VkPSR7bGFzdFByb2Nlc3NlZENvbnRleHR9LCBjb29sZG93bj0ke3RpbWVTaW5jZUxhc3RDaGFuZ2V9bXNgKTtcbiAgICAgICAgaWYgKGNvbnRleHQgIT09ICdpZGxlJyAmJiBjb250ZXh0ICE9PSBsYXN0UHJvY2Vzc2VkQ29udGV4dCAmJiB0aW1lU2luY2VMYXN0Q2hhbmdlID49IEVNT1RJT05fQ09PTERPV04pIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhg8J+OrSBUUklHR0VSSU5HIGVtb3Rpb24gY2hhbmdlIGZvciBjb250ZXh0ICcke2NvbnRleHR9J2ApO1xuICAgICAgICBjb25zdCByYW5kb21FbW90aW9uID0gZW1vdGlvbnNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogZW1vdGlvbnMubGVuZ3RoKV07XG4gICAgICAgICAgY2hhbmdlRW1vdGlvbihyYW5kb21FbW90aW9uLCBmYWxzZSk7IC8vIE1pdCBGbGlwLUFuaW1hdGlvblxuICAgICAgICAgIHNldExhc3RQcm9jZXNzZWRDb250ZXh0KGNvbnRleHQpOyAvLyBNZXJrZSBkYXNzIHdpciBkaWVzZW4gQ29udGV4dCBzY2hvbiB2ZXJhcmJlaXRldCBoYWJlblxuICAgICAgICAgIHNldExhc3RFbW90aW9uQ2hhbmdlVGltZShub3cpOyAvLyBTZXR6ZSBDb29sZG93bi1UaW1lclxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQgPT09IGxhc3RQcm9jZXNzZWRDb250ZXh0KSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYPCfjq0gQkxPQ0tFRDogQ29udGV4dCAnJHtjb250ZXh0fScgYWxyZWFkeSBwcm9jZXNzZWRgKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aW1lU2luY2VMYXN0Q2hhbmdlIDwgRU1PVElPTl9DT09MRE9XTikge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn46tIEJMT0NLRUQ6IENvb2xkb3duIGFjdGl2ZSAoJHt0aW1lU2luY2VMYXN0Q2hhbmdlfW1zIDwgJHtFTU9USU9OX0NPT0xET1dOfW1zKWApO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQgPT09ICdpZGxlJykge1xuICAgICAgICAgIC8vIEJlaSBpZGxlLUNvbnRleHQ6IFJlc2V0IGxhc3RQcm9jZXNzZWRDb250ZXh0IGbDvHIgbsOkY2hzdGUgSW50ZXJha3Rpb24gKGFiZXIga2VpbiBDb29sZG93biBSZXNldClcbiAgICAgICAgICBjb25zb2xlLmxvZyhg8J+OrSBSRVNFVDogSWRsZSBjb250ZXh0LCBjbGVhcmluZyBsYXN0UHJvY2Vzc2VkQ29udGV4dGApO1xuICAgICAgICAgIHNldExhc3RQcm9jZXNzZWRDb250ZXh0KG51bGwpO1xuICAgICAgICAgIC8vIENoYXJhY3RlciB3aXJkIE5JQ0hUIG5ldSBpbnN0YW56aWVydCwgbnVyIGhhc0xvYWRlZCBibGVpYnQgdHJ1ZVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIGNvbnRleHQgZW1vdGlvbnM6JywgZXJyb3IpO1xuICAgICAgc2V0QXZhaWxhYmxlRW1vdGlvbnMoWydpZGxlJywgJ2N1cmlvdXMnXSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFp1ZsOkbGxpZ2VzIExhY2hlbiBhYnNwaWVsZW4gKG9obmUgVm9pY2UtT3ZlcnMgenUgdW50ZXJicmVjaGVuKVxuICBjb25zdCBwbGF5UmFuZG9tTGF1Z2h0ZXIgPSAoKSA9PiB7XG4gICAgY29uc3QgbGF1Z2h0ZXJGaWxlcyA9IFtcbiAgICAgICcvYXVkaW8vTGF1Z2hpbmdLaWQvbGF1Z2hpbmctMS53YXYnLFxuICAgICAgJy9hdWRpby9MYXVnaGluZ0tpZC9sYXVnaGluZy0yLndhdicsXG4gICAgICAnL2F1ZGlvL0xhdWdoaW5nS2lkL2xhdWdoaW5nLTMud2F2JyxcbiAgICAgICcvYXVkaW8vTGF1Z2hpbmdLaWQvbGF1Z2hpbmctNC53YXYnLFxuICAgICAgJy9hdWRpby9MYXVnaGluZ0tpZC9sYXVnaGluZy01LndhdicsXG4gICAgICAnL2F1ZGlvL0xhdWdoaW5nS2lkL2xhdWdoaW5nLTYud2F2JyxcbiAgICAgICcvYXVkaW8vTGF1Z2hpbmdLaWQvbGF1Z2hpbmctNy53YXYnXG4gICAgXTtcbiAgICBcbiAgICAvLyBadWbDpGxsaWdlIExhY2hlci1EYXRlaSBhdXN3w6RobGVuXG4gICAgY29uc3QgcmFuZG9tTGF1Z2h0ZXIgPSBsYXVnaHRlckZpbGVzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGxhdWdodGVyRmlsZXMubGVuZ3RoKV07XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIFNFUEFSQVRFUyBBdWRpby1FbGVtZW50IGbDvHIgTGFjaGVyIChuaWNodCBnbG9iYWwhKVxuICAgICAgY29uc3QgbGF1Z2h0ZXJBdWRpbyA9IG5ldyBBdWRpbyhyYW5kb21MYXVnaHRlcik7XG4gICAgICBsYXVnaHRlckF1ZGlvLnZvbHVtZSA9IDAuNzsgLy8gRXR3YXMgbGVpc2VyIGFscyBWb2ljZS1PdmVyc1xuICAgICAgXG4gICAgICBsYXVnaHRlckF1ZGlvLnBsYXkoKS5jYXRjaChlcnIgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnTGFjaGVyLUF1ZGlvIGF1dG9wbGF5IHZlcmhpbmRlcnQ6JywgZXJyKTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygn8J+koyBMYWNoZXIgYWJnZXNwaWVsdDonLCByYW5kb21MYXVnaHRlcik7XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignTGFjaGVyLUF1ZGlvLUZlaGxlcjonLCBlcnJvcik7XG4gICAgfVxuICB9O1xuXG4gIC8vIENoYXJhY3RlciBhbnRpcHBlbiAtIFJvdGF0aW9uLCBFbW90aW9uLVdlY2hzZWwgVU5EIExhY2hlblxuICBjb25zdCBoYW5kbGVDaGFyYWN0ZXJDbGljayA9ICgpID0+IHtcbiAgICAvLyBadSBsYXVnaGluZyBvZGVyIGV4Y2l0ZWQgd2VjaHNlbG4sIGFiZXIgTklFTUFMUyBkaWUgYWt0dWVsbGUgRW1vdGlvblxuICAgIGNvbnN0IGhhcHB5RW1vdGlvbnMgPSBbJ2xhdWdoaW5nJywgJ2V4Y2l0ZWQnXTtcbiAgICBsZXQgcmFuZG9tSGFwcHlFbW90aW9uO1xuICAgIFxuICAgIC8vIEFuZGVyZSBFbW90aW9uIHfDpGhsZW4gYWxzIGRpZSBha3R1ZWxsZVxuICAgIGlmIChjdXJyZW50RW1vdGlvbiA9PT0gJ2xhdWdoaW5nJykge1xuICAgICAgcmFuZG9tSGFwcHlFbW90aW9uID0gJ2V4Y2l0ZWQnO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudEVtb3Rpb24gPT09ICdleGNpdGVkJykge1xuICAgICAgcmFuZG9tSGFwcHlFbW90aW9uID0gJ2xhdWdoaW5nJzsgIFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZW5uIHdlZGVyIGxhdWdoaW5nIG5vY2ggZXhjaXRlZCwgenVmw6RsbGlnIHfDpGhsZW5cbiAgICAgIHJhbmRvbUhhcHB5RW1vdGlvbiA9IGhhcHB5RW1vdGlvbnNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogaGFwcHlFbW90aW9ucy5sZW5ndGgpXTtcbiAgICB9XG4gICAgXG4gICAgY2hhbmdlRW1vdGlvbihyYW5kb21IYXBweUVtb3Rpb24sIGZhbHNlKTsgLy8gTWl0IEZsaXAtQW5pbWF0aW9uXG4gICAgc2V0TGFzdEVtb3Rpb25DaGFuZ2VUaW1lKERhdGUubm93KCkpOyAvLyBDb29sZG93bi1UaW1lciBhdWNoIGJlaSBkaXJla3RlbSBDaGFyYWN0ZXItS2xpY2sgc2V0emVuXG4gICAgXG4gICAgLy8gWnVmw6RsbGlnZXMgTGFjaGVuIGFic3BpZWxlbiAocGFyYWxsZWwgenUgVm9pY2UtT3ZlcnMpXG4gICAgcGxheVJhbmRvbUxhdWdodGVyKCk7XG4gICAgXG4gICAgLy8gQ2FsbGJhY2sgZsO8ciBFbW90aW9uLcOEbmRlcnVuZ1xuICAgIGlmIChvbkVtb3Rpb25DaGFuZ2UpIHtcbiAgICAgIG9uRW1vdGlvbkNoYW5nZShyYW5kb21IYXBweUVtb3Rpb24pO1xuICAgIH1cbiAgfTtcblxuICAvLyBJbml0aWFsIEZseS1JbiBBbmltYXRpb24gc3RhcnRlbiAtIE5VUiBFSU5NQUwgaW4gZGVyIGdlc2FtdGVuIEFwcC1MYXVmemVpdFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghY2hhcmFjdGVySW5pdGlhbGl6ZWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKGDwn46tIENoYXJhY3RlciBGSVJTVCBUSU1FIElOSVRJQUxJWkFUSU9OYCk7XG4gICAgICBjaGFyYWN0ZXJJbml0aWFsaXplZCA9IHRydWU7IC8vIFNldHplIHN0YXRpc2NoZSBWYXJpYWJsZVxuICAgICAgXG4gICAgICAvLyBOYWNoIGt1cnplciBWZXJ6w7ZnZXJ1bmcgQ2hhcmFjdGVyIHJlaW5mbGllZ2VuIGxhc3NlblxuICAgICAgY29uc3QgbG9hZFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKGDwn46tIFNldHRpbmcgaGFzTG9hZGVkIHRvIHRydWVgKTtcbiAgICAgICAgc2V0SGFzTG9hZGVkKHRydWUpO1xuICAgICAgfSwgMzAwKTtcbiAgICAgIFxuICAgICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dChsb2FkVGltZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhg8J+OrSBDaGFyYWN0ZXIgQUxSRUFEWSBJTklUSUFMSVpFRCAtIHNldHRpbmcgaGFzTG9hZGVkIGltbWVkaWF0ZWx5YCk7XG4gICAgICBzZXRIYXNMb2FkZWQodHJ1ZSk7IC8vIEJlaSBSZS1SZW5kZXIgc29mb3J0IGF1ZiBsb2FkZWQgc2V0emVuXG4gICAgfVxuICB9LCBbXSk7XG5cbiAgLy8gQ29udGV4dC3DhG5kZXJ1bmdlbiDDvGJlcndhY2hlbiAtIG1pdCBSZWYgdW0gZG9wcGVsdGUgQXVmcnVmZSB6dSB2ZXJoaW5kZXJuXG4gIGNvbnN0IGxhc3RDb250ZXh0UmVmID0gdXNlUmVmKG51bGwpO1xuICBcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoY3VycmVudENvbnRleHQgJiYgY3VycmVudENvbnRleHQgIT09IGxhc3RDb250ZXh0UmVmLmN1cnJlbnQpIHtcbiAgICAgIGNvbnNvbGUubG9nKGDwn46tIFByb2Nlc3NpbmcgTkVXIGNvbnRleHQ6ICcke2N1cnJlbnRDb250ZXh0fSdgKTtcbiAgICAgIGxhc3RDb250ZXh0UmVmLmN1cnJlbnQgPSBjdXJyZW50Q29udGV4dDtcbiAgICAgIGxvYWRDb250ZXh0RW1vdGlvbnMoY3VycmVudENvbnRleHQpO1xuICAgIH1cbiAgfSwgW2N1cnJlbnRDb250ZXh0XSk7XG5cbiAgLy8gQ2xlYW51cCBUaW1lclxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoYXV0b1Jlc2V0VGltZXIuY3VycmVudCkgY2xlYXJUaW1lb3V0KGF1dG9SZXNldFRpbWVyLmN1cnJlbnQpO1xuICAgICAgaWYgKGVtb3Rpb25DaGFuZ2VUaW1lci5jdXJyZW50KSBjbGVhclRpbWVvdXQoZW1vdGlvbkNoYW5nZVRpbWVyLmN1cnJlbnQpO1xuICAgIH07XG4gIH0sIFtdKTtcblxuICAvLyBQcmVsb2FkIGltYWdlIHZpYSBCYXNlNjQgY2FjaGUsIGJ1dCBkbyBub3QgdXNlIGl0IGZvciByZW5kZXJpbmdcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXNlbGVjdGVkVmFyaWFudCkgcmV0dXJuO1xuICAgIGdldENhY2hlZEFzc2V0KHNlbGVjdGVkVmFyaWFudCkuY2F0Y2goKCkgPT4ge30pO1xuICB9LCBbc2VsZWN0ZWRWYXJpYW50XSk7XG5cbiAgLy8gVHJhY2sgbG9hZGluZyBzdGF0ZSBmb3IgdGhlIHJlYWwgaW1hZ2VcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQgZGlkQ2FuY2VsID0gZmFsc2U7XG4gICAgbGV0IGZhbGxiYWNrVGltZXI7XG4gICAgc2V0SW1nTG9hZGVkKGZhbHNlKTtcbiAgICBpZiAoc2VsZWN0ZWRWYXJpYW50KSB7XG4gICAgICBmYWxsYmFja1RpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICghZGlkQ2FuY2VsKSBzZXRJbWdMb2FkZWQodHJ1ZSk7XG4gICAgICB9LCA1MDApO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZGlkQ2FuY2VsID0gdHJ1ZTtcbiAgICAgIGlmIChmYWxsYmFja1RpbWVyKSBjbGVhclRpbWVvdXQoZmFsbGJhY2tUaW1lcik7XG4gICAgfTtcbiAgfSwgW3NlbGVjdGVkVmFyaWFudF0pO1xuXG4gIC8vIEFuaW1hdGlvbi1LbGFzc2VuIGJlc3RpbW1lblxuICBjb25zdCBnZXRBbmltYXRpb25DbGFzc2VzID0gKCkgPT4ge1xuICAgIGxldCBjbGFzc2VzID0gJ2NoYXJhY3Rlci1pbWFnZSc7XG4gICAgXG4gICAgLy8gSW5pdGlhbCBGbHktSW4gQW5pbWF0aW9uIGJlaW0gZXJzdGVuIExhZGVuXG4gICAgaWYgKCFoYXNMb2FkZWQpIHtcbiAgICAgIGNsYXNzZXMgKz0gJyBjaGFyYWN0ZXItZmx5LWluJztcbiAgICAgIGNvbnNvbGUubG9nKGDwn46oIENTUyBDbGFzc2VzOiAke2NsYXNzZXN9IChmbHktaW4pYCk7XG4gICAgICByZXR1cm4gY2xhc3NlcztcbiAgICB9XG4gICAgXG4gICAgLy8gUm90YXRpb24tQW5pbWF0aW9uIGhhdCBQcmlvcml0w6R0XG4gICAgaWYgKHJvdGF0aW9uUGhhc2UgPT09ICdvdXQnKSB7XG4gICAgICBjbGFzc2VzICs9ICcgY2hhcmFjdGVyLXJvdGF0ZS1vdXQnO1xuICAgICAgY29uc29sZS5sb2coYPCfjqggQ1NTIENsYXNzZXM6ICR7Y2xhc3Nlc30gKHJvdGF0aW5nIE9VVClgKTtcbiAgICB9IGVsc2UgaWYgKHJvdGF0aW9uUGhhc2UgPT09ICdpbicpIHtcbiAgICAgIGNsYXNzZXMgKz0gJyBjaGFyYWN0ZXItcm90YXRlLWluJztcbiAgICAgIGNvbnNvbGUubG9nKGDwn46oIENTUyBDbGFzc2VzOiAke2NsYXNzZXN9IChyb3RhdGluZyBJTilgKTtcbiAgICB9IGVsc2UgaWYgKHJvdGF0aW9uUGhhc2UgPT09ICdpZGxlJyAmJiAhaXNSb3RhdGluZykge1xuICAgICAgLy8gU3VidGlsZSBMb29wLUFuaW1hdGlvbiBudXIgd2VubiB3aXJrbGljaCBpZGxlXG4gICAgICBjbGFzc2VzICs9ICcgY2hhcmFjdGVyLXN1YnRsZS1hbmltYXRpb24nO1xuICAgICAgY29uc29sZS5sb2coYPCfjqggQ1NTIENsYXNzZXM6ICR7Y2xhc3Nlc30gKHN1YnRsZSBpZGxlKWApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhg8J+OqCBDU1MgQ2xhc3NlczogJHtjbGFzc2VzfSAobm8gZXh0cmEgYW5pbWF0aW9uKWApO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gY2xhc3NlcztcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgXG4gICAgICBjbGFzc05hbWU9XCJjaGFyYWN0ZXItY29udGFpbmVyXCJcbiAgICAgIG9uQ2xpY2s9e2hhbmRsZUNoYXJhY3RlckNsaWNrfVxuICAgICAgdGl0bGU9XCJDaGFyYWN0ZXIgYW50aXBwZW4gZsO8ciBFbW90aW9uZW4hXCJcbiAgICA+XG4gICAgICA8aW1nXG4gICAgICAgIHNyYz17aW1nU3JjfVxuICAgICAgICBhbHQ9e2BDaGFyYWN0ZXIgJHtjdXJyZW50RW1vdGlvbn1gfVxuICAgICAgICB3aWR0aD17MTIwfVxuICAgICAgICBoZWlnaHQ9ezE1MH1cbiAgICAgICAgY2xhc3NOYW1lPXtnZXRBbmltYXRpb25DbGFzc2VzKCl9XG4gICAgICAgIHN0eWxlPXt7IG9iamVjdEZpdDogJ2NvbnRhaW4nLCBwb3NpdGlvbjogJ3JlbGF0aXZlJywgekluZGV4OiAxLCBvcGFjaXR5OiBpbWdMb2FkZWQgPyAxIDogMCwgdHJhbnNpdGlvbjogJ29wYWNpdHkgMC4ycycgfX1cbiAgICAgICAgb25Mb2FkPXsoKSA9PiBzZXRJbWdMb2FkZWQodHJ1ZSl9XG4gICAgICAgIG9uRXJyb3I9eygpID0+IHNldEltZ0xvYWRlZCh0cnVlKX1cbiAgICAgIC8+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBDaGFyYWN0ZXI7IFxuLy8gQ2FjaGUtUmVmcmVzaDogVXBkYXRlZCBDaGFyYWN0ZXIgQW5pbWF0aW9uIGFuZCByZW1vdmVkIGlzQm91bmNpbmcgIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlUmVmIiwiSW1hZ2UiLCJnZXRDYWNoZWRBc3NldCIsImNoYXJhY3RlckluaXRpYWxpemVkIiwiQ2hhcmFjdGVyIiwiY3VycmVudENvbnRleHQiLCJvbkVtb3Rpb25DaGFuZ2UiLCJjdXJyZW50RW1vdGlvbiIsInNldEN1cnJlbnRFbW90aW9uIiwiaXNSb3RhdGluZyIsInNldElzUm90YXRpbmciLCJyb3RhdGlvblBoYXNlIiwic2V0Um90YXRpb25QaGFzZSIsImF2YWlsYWJsZUVtb3Rpb25zIiwic2V0QXZhaWxhYmxlRW1vdGlvbnMiLCJoYXNMb2FkZWQiLCJzZXRIYXNMb2FkZWQiLCJsYXN0UHJvY2Vzc2VkQ29udGV4dCIsInNldExhc3RQcm9jZXNzZWRDb250ZXh0IiwibGFzdEVtb3Rpb25DaGFuZ2VUaW1lIiwic2V0TGFzdEVtb3Rpb25DaGFuZ2VUaW1lIiwiYXV0b1Jlc2V0VGltZXIiLCJlbW90aW9uQ2hhbmdlVGltZXIiLCJjaGFyYWN0ZXJWYXJpYW50cyIsImlkbGUiLCJleGNpdGVkIiwiY3VyaW91cyIsInN1cnByaXNlZCIsInRoaW5raW5nIiwibGF1Z2hpbmciLCJleHBsb3JpbmciLCJzY2FyZWQiLCJzZWxlY3RlZFZhcmlhbnQiLCJzZXRTZWxlY3RlZFZhcmlhbnQiLCJpbWdMb2FkZWQiLCJzZXRJbWdMb2FkZWQiLCJpbWdTcmMiLCJzZXRJbWdTcmMiLCJpc01vdW50ZWQiLCJ0aGVuIiwiYmFzZTY0IiwiY2F0Y2giLCJzZWxlY3RWYXJpYW50Rm9yRW1vdGlvbiIsImVtb3Rpb24iLCJ2YXJpYW50cyIsImxlbmd0aCIsInZhcmlhbnQiLCJvdGhlclZhcmlhbnRzIiwiZmlsdGVyIiwicmFuZG9tVmFyaWFudCIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsImdldFJhbmRvbUVtb3Rpb24iLCJlbW90aW9ucyIsImZpbHRlcmVkIiwiZSIsImNoYW5nZUVtb3Rpb24iLCJuZXdFbW90aW9uIiwiaW1tZWRpYXRlIiwiY29uc29sZSIsImxvZyIsInNldFRpbWVvdXQiLCJsb2FkQ29udGV4dEVtb3Rpb25zIiwiY29udGV4dCIsImNvbnRleHRFbW90aW9uTWFwIiwibWFpbiIsImNhdGVnb3J5IiwiYW5pbWFscyIsImRlZmF1bHQiLCJub3ciLCJEYXRlIiwidGltZVNpbmNlTGFzdENoYW5nZSIsIkVNT1RJT05fQ09PTERPV04iLCJyYW5kb21FbW90aW9uIiwiZXJyb3IiLCJwbGF5UmFuZG9tTGF1Z2h0ZXIiLCJsYXVnaHRlckZpbGVzIiwicmFuZG9tTGF1Z2h0ZXIiLCJsYXVnaHRlckF1ZGlvIiwiQXVkaW8iLCJ2b2x1bWUiLCJwbGF5IiwiZXJyIiwiaGFuZGxlQ2hhcmFjdGVyQ2xpY2siLCJoYXBweUVtb3Rpb25zIiwicmFuZG9tSGFwcHlFbW90aW9uIiwibG9hZFRpbWVyIiwiY2xlYXJUaW1lb3V0IiwibGFzdENvbnRleHRSZWYiLCJjdXJyZW50IiwiZGlkQ2FuY2VsIiwiZmFsbGJhY2tUaW1lciIsImdldEFuaW1hdGlvbkNsYXNzZXMiLCJjbGFzc2VzIiwiZGl2IiwiY2xhc3NOYW1lIiwib25DbGljayIsInRpdGxlIiwiaW1nIiwic3JjIiwiYWx0Iiwid2lkdGgiLCJoZWlnaHQiLCJzdHlsZSIsIm9iamVjdEZpdCIsInBvc2l0aW9uIiwiekluZGV4Iiwib3BhY2l0eSIsInRyYW5zaXRpb24iLCJvbkxvYWQiLCJvbkVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./components/Character.js\n"));

/***/ })

});